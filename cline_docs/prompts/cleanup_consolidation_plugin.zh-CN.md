# **Cline 递归思维链系统 (CRCT) - 清理/整合插件**

**本插件为 CRCT 系统的清理/整合阶段提供详细指令和流程。应与核心系统提示词结合使用。**

---

## I. 进入和退出清理/整合阶段

**进入清理/整合阶段：**
1. **`.clinerules` 检查**：始终首先读取 `.clinerules`。如果 `[LAST_ACTION_STATE]` 显示 `next_phase: "Cleanup/Consolidation"`，则按这些指令执行。此阶段通常在执行阶段之后。
2. **用户触发**：如果系统在执行后暂停，等待此阶段，则启动新会话。

**退出清理/整合阶段：**
1. **完成标准：**
   - 整合步骤（第 III 节）完成：相关信息集成到持久文档，变更日志重组完成。
   - 清理步骤（第 IV 节）完成：过时文件已识别并归档/删除。
   - `activeContext.md` 反映了干净、整合后的状态。
   - 所有操作遵循 MUP。
2. **`.clinerules` 更新（MUP）：**
   - 通常过渡回设置/维护阶段进行验证，或过渡到策略阶段开始下一个规划周期：
     ```
     [LAST_ACTION_STATE]
     last_action: "Completed Cleanup/Consolidation Phase"
     current_phase: "Cleanup/Consolidation"
     next_action: "Phase Complete - User Action Required"
     next_phase: "Set-up/Maintenance" # 或者如果立即规划下一周期则为 "Strategy"
     ```
   - *备选：如果项目现在被认为已完全完成：*
     ```
     [LAST_ACTION_STATE]
     last_action: "Completed Cleanup/Consolidation Phase - Project Finalized"
     current_phase: "Cleanup/Consolidation"
     next_action: "Project Completion - User Review"
     next_phase: "Project Complete"
     ```
3. **用户操作**：更新 `.clinerules` 后，暂停以便用户触发下一阶段。

---

## II. 阶段目标

**目标**：系统性审查执行周期后的项目状态，将核心信息和学习成果整合到持久文档（HDTA、核心文件），**按组件重组变更日志以提高可读性**，并清理临时或过时文件（如已完成的任务指令、会话追踪器和临时整合笔记），以维护一个聚焦且相关的项目上下文。

**工作流程顺序**：整合必须在清理之前完成。

---

## III. 整合工作流程

**目标**：将最近执行周期的关键信息、决策和学习成果综合到核心项目文档中，并按组件/模块重组变更日志。

<<<***关键警告***>>>
*你**必须**通过手动读取基础文件来验证其状态，以确定完成状态。对于代码文件，读取实际代码。对于文档，读取相关文档。*

**流程：**

1.  **审查和验证所有相关项目文档和任务状态（关键）**：
    *   **a. 识别 HDTA 文档结构和其他战略追踪器**：
        *   **操作**：审查 `cline_docs/templates/` 中的文件，了解所有 HDTA 文档层级的标准结构和预期内容（`system_manifest.md`、`*_module.md`、`implementation_plan_*.md`、`task_instruction.md`）。
        *   **操作**：使用 `list_files` 在 `cline_docs/` 内搜索（如果使用自定义位置，也搜索其他相关项目文档目录）匹配 `*roadmap*.md`、`*checklist*.md`、`*review_progress*.md` 或其他战略追踪文档的文件。
        *   **目的**：确保完全理解项目的预期文档结构，并识别所有需要审查和整合的高级追踪文档。
    *   **b. 列出所有任务指令文件**：
        *   **操作**：使用 `list_files` 递归识别主 `tasks/` 目录（及其子目录）中的所有 `*.md` 文件。
        *   **操作**：使用 `list_files` 递归识别*整个* `cline_docs/archive/` 目录（及其子目录）中的所有 `*.md` 文件，以定位任何先前归档的任务文件。
        *   **目的**：创建所有可用任务指令文件的全面列表，无论其当前位置（活动或已归档），以便后续分批审查。
    *   **c. 列出所有实施计划文件**：
        *   **操作**：对于 `[CODE_ROOT_DIRECTORIES]`（来自 `.clinerules`）中列出的每个目录，使用 `list_files` 递归识别所有匹配 `implementation_plan_*.md` 模式的文件。这些通常位于模块目录中（例如，`src/module_name/implementation_plan_*.md`）。
        *   **目的**：创建所有实施计划文件的全面列表，以便后续分批审查。
    *   **d. 读取核心项目状态文件**：
        *   **操作**：读取 `activeContext.md`：识别关键决策、未解决问题和已完成工作的摘要。
        *   **操作**：读取 `changelog.md`：审查所有重大更改。**（注意：将在步骤 3 中重组）**。
        *   **操作**：读取 `progress.md`：检查所有高级里程碑。
        *   **目的**：收集将为整合过程提供信息的当前项目状态信息。
    *   **e. 分批审查所有已识别的任务指令文件（关键）**：
        *   **目的**：识别重要的实施细节、设计选择、"陷阱"、学习成果，并**关键性验证任务的实际完成状态**。此审查涵盖步骤 1b 中识别的所有任务指令文件，分批处理以防止上下文过载。
        *   **流程**：
            i. **批次创建**：
                - **操作**：将任务指令文件的全面列表（来自步骤 1b）分成批次，每批包含**不超过 10 个文件**。如果文件总数不能被 10 整除，最后一批可能包含少于 10 个文件。
                - **操作**：维护已处理文件的记录，以确保不遗漏或重复处理任何文件。这可以在内部完成，或通过更新临时追踪机制（例如，在此阶段期间在 `activeContext.md` 中添加注释）。
            ii. **处理每个批次（独立处理）**：
                - **操作**：对于每批最多 10 个任务指令文件，**将批次作为独立任务完全处理**，然后再继续下一批次。这意味着完成批次中所有文件的所有验证、提取和更新操作，这些操作之间没有批次间依赖关系。
                - **子流程（针对批次中的每个文件）**：
                    1. **读取任务文件**：
                        - **操作**：使用 `read_file` 读取任务文件的内容。
                    2. **验证完成（手动且关键）**：
                        - **验证方法**：
                            - 对于**执行任务**：如果任务文件表明对项目工件执行了具体操作（例如，"将 x 应用于 y"，"创建文件 z"，"修改文件 w 中的函数 f"，"更新文档 q"），你**必须**通过检查目标工件手动验证此结果。
                            - 对于**策略任务**：验证涉及确认策略任务的计划输出（例如，设计文档、研究摘要、一组定义的需求、已完成的探索）已产生、完整且满足任务目标。这可能涉及读取输出文档，或评估任务文件本身呈现的战略分析的完整性。
                        - **操作**：使用 `read_file` 检查目标工件或输出文档，或根据需要使用 `list_files` 确认存在/修改。如果变更日志条目提供与任务相关的特定文件修改详细信息，请参考 `changelog.md` 条目。
                        - **如果结果未验证**（例如，'x' 未应用于 'y'，文件 'z' 不包含预期内容，函数 'f' 未按描述修改）：
                            - 为此任务文件明确记录此差异。
                            - **操作（关键）**：如果任务文件有 "Status: Completed" 标记（或其所有内部步骤都已勾选，暗示完成），则此状态现在被视为**无效**。你**必须**更新任务文件本身，删除或明确标记 "Completed" 状态为不正确/未验证（例如，更改为 "Status: Pending Verification" 或 "Status: Incomplete - Outcome Not Verified"）。
                            - **操作（关键）**：识别**所有**将此任务引用为已完成的文档。这包括（但不限于）父实施计划、任何 `*checklist*.md` 文件、`*roadmap*.md` 文件、`progress.md`，以及可能的 `activeContext.md`。更新这些引用文档以反映任务的真实（未验证/未完成）状态。
                            - **注意**：此任务文件**不得**在第 IV 节中作为 "完成" 归档。它可能需要在后续阶段创建新任务来解决未完成的问题。
                    3. **提取可整合信息（关键）**：
                        - 无论验证的完成状态如何，识别任务文件*内部*记录的任何设计决策、新信息、重要学习、"陷阱"或与原始计划的偏差。
                        - **操作**：将此信息记录在 `cline_docs/` 中的临时文件 `consolidation_notes.md` 中。为每条信息附加源文件和批次编号的引用（例如，"批次 1，task_abc.md：了解到算法 X 对于大型数据集不是最优的"）。使用 `write_to_file` 或 `apply_diff` 更新 `consolidation_notes.md`。
                - **操作**：在完全处理当前批次中的所有文件后（即所有文件都已读取、验证、必要时更新，并且它们的可整合信息已记录在 `consolidation_notes.md` 中），在 `activeContext.md` 中记录批次的完成情况（例如，"完成批次 X 的验证和提取，包含文件 [file1, file2, ...]。信息记录在 `consolidation_notes.md` 中。"）。只有这样才能继续下一批次。
                - **目的**：将每个批次作为独立任务处理，确保完成所有关键操作，而不依赖于未来的批次，在保持全面验证和提取的同时减少上下文过载。
    *   **f. 分批审查所有已识别的实施计划文件（关键）**：
        *   **目的**：整合战略决策、结果，并确保与已完成（且已验证）的任务保持一致。此审查涵盖步骤 1c 中识别的所有文件，分批处理以防止上下文过载。
        *   **流程**：
            i. **批次创建**：
                - **操作**：将实施计划文件的全面列表（来自步骤 1c）分成批次，每批包含**不超过 10 个文件**。如果文件总数不能被 10 整除，最后一批可能包含少于 10 个文件。
                - **操作**：维护已处理文件的记录，以确保不遗漏或重复处理任何文件。
            ii. **处理每个批次（独立处理）**：
                - **操作**：对于每批最多 10 个实施计划文件，**将批次作为独立任务完全处理**，然后再继续下一批次。这意味着完成批次中所有文件的所有读取、分析、更新和提取操作，这些操作之间没有批次间依赖关系。
                - **子流程（针对批次中的每个文件）**：
                    1. **读取实施计划**：
                        - **操作**：使用 `read_file` 读取实施计划的内容。
                    2. 识别计划中描述的任何高级战略决策、架构更改或总体结果。
                    3. 将计划中列出的任务与步骤 1e 中确定的验证状态进行交叉引用。更新实施计划以准确反映其子任务的真实完成状态。
                    4. **提取可整合信息**：
                        - 标记任何尚未在更高级别 HDTA 文档（如 `system_manifest.md` 或 `*_module.md` 文件）中捕获的重要战略信息。
                        - **操作**：将此信息记录在 `cline_docs/` 中的 `consolidation_notes.md` 中，为每条信息附加源文件和批次编号的引用（例如，"批次 2，implementation_plan_feature_y.md：决定使用微服务以提高可扩展性"）。
                - **操作**：在完全处理当前批次中的所有文件后（即所有文件都已读取、更新，并且它们的可整合信息已记录在 `consolidation_notes.md` 中），在 `activeContext.md` 中记录批次的完成情况（例如，"完成批次 Y 的验证和提取，包含实施计划 [plan1, plan2, ...]。信息记录在 `consolidation_notes.md` 中。"）。只有这样才能继续下一批次。
                - **目的**：将每个批次作为独立任务处理，确保可管理地处理实施计划，保持与已验证任务状态的一致性。
    *   **g. 分批审查其他战略追踪文档（路线图、检查清单等）（关键）**：
        *   **目的**：确保所有高级追踪文档都是最新的，并且旧版本中的未完成项目不会丢失。此审查涵盖步骤 1a 中识别的所有文件（不包括 HDTA 模板），分批处理以防止上下文过载。
        *   **流程**：
            i. **批次创建**：
                - **操作**：将战略追踪文档的全面列表（来自步骤 1a，例如，`*roadmap*.md`、`*checklist*.md`、`*review_progress*.md`）分成批次，每批包含**不超过 10 个文件**。如果文件总数不能被 10 整除，最后一批可能包含少于 10 个文件。
                - **操作**：维护已处理文件的记录，以确保不遗漏或重复处理任何文件。
            ii. **处理每个批次（独立处理）**：
                - **操作**：对于每批最多 10 个战略追踪文档，**将批次作为独立任务完全处理**，然后再继续下一批次。这意味着完成批次中所有文件的所有读取、整合、更新和提取操作，这些操作之间没有批次间依赖关系。
                - **子流程（针对批次中的每个文件）**：
                    1. 如果存在同一概念追踪器的多个版本（例如，`project_checklist_v1.md`、`project_checklist_v2.md`）：
                        - **操作**：读取批次中的所有版本。
                        - **操作（关键）**：识别*最新*版本。将*旧*版本中的所有未完成或待处理项目整合到此最新版本中。
                        - **操作（关键）**：确保旧版本中记录的所有重要已完成项目和学习成果都适当地反映在持久项目文档（HDTA、变更日志等）中，或者如果对上下文仍然相关，则转移到最新的追踪器版本。
                        - 一旦旧版本完全整合（其所有独特的、仍然相关的信息都已转移），它就可以在第 IV 节中考虑归档。最新版本成为活动追踪器。
                    2. 对于每个追踪器的活动/最新版本，根据已验证的任务状态（来自步骤 1e）和实施计划审查（步骤 1f）审查其项目。更新追踪器以准确反映项目进度。
                    3. **提取可整合信息**：
                        - 标记任何用于更广泛整合的战略见解或状态更新（例如，整合到 `activeContext.md` 或 `progress.md` 中）。
                        - **操作**：将此信息记录在 `cline_docs/` 中的 `consolidation_notes.md` 中，为每条信息附加源文件和批次编号的引用（例如，"批次 3，roadmap_v3.md：根据任务延迟更新了里程碑优先级"）。
                - **操作**：在完全处理当前批次中的所有文件后（即所有文件都已读取、整合、更新，并且它们的可整合信息已记录在 `consolidation_notes.md` 中），在 `activeContext.md` 中记录批次的完成情况（例如，"完成批次 Z 的验证和提取，包含追踪器 [tracker1, tracker2, ...]。信息记录在 `consolidation_notes.md` 中。"）。只有这样才能继续下一批次。
                - **目的**：将每个批次作为独立任务处理，确保可管理地处理战略追踪器，保持全面整合。

2.  **识别所有待整合信息（关键）**：
    *   基于步骤 1 中执行的全面审查（涵盖所有任务指令、实施计划、战略追踪器和核心状态文件），**关键性**列出所有代表持久设计决策、架构更改、重大结果、精炼需求、重要运营学习、"陷阱"或任何其他**必须**集成到持久项目文档中的重要知识的具体信息。此列表不仅限于最近运营周期的发现，而是涵盖审查的整个项目历史。（不包括此步骤的变更日志结构重组，该重组在步骤 3b 中处理）。

3.  **更新持久文档并重组变更日志**：

    *   **a. 更新标准文档（HDTA、核心文件）（关键）**：
        *   **目的**：确保所有持久项目文档准确反映从步骤 2 的 `consolidation_notes.md` 中收集的整合知识。这是维护项目最新和可靠知识库的**关键**步骤。
        *   **HDTA 文档**：
            *   **操作（关键）**：如果整体架构、核心组件或项目目标在任何时候发生演变或得到澄清，则更新 `system_manifest.md`。
            *   **操作（关键）**：更新相关的领域模块（`*_module.md`），纳入精炼的描述、接口更改、关键实施说明或发现的任何其他重要学习成果。
            *   **操作（关键）**：更新相关的实施计划（`implementation_plan_*.md`），记录最终结果、与原始计划的偏差或在任何实施工作期间做出的重大决策。确保它们准确反映其子任务的已验证完成状态。
            *   **流程**：对于每个需要更新的 HDTA 文档：使用 `read_file` 加载目标文档，逻辑清晰地集成整合信息，并使用 `write_to_file` 保存更改。**说明每次更新的理由，引用整合信息的来源（例如，特定任务文件、`activeContext.md` 见解）。** 示例："将模块 Y 的最终算法选择（来自已归档任务 `cline_docs/archive/tasks/task_abc.md`）整合到 `src/module_y/module_y_module.md` 中。"
        *   **核心文件**：
            *   **操作（关键）**：根据已验证的结果，更新 `progress.md` 以准确标记所有已完成的高级检查清单项目。
            *   **操作（关键）**：使用任何新观察到或强化的用户偏好或交互模式更新 `userProfile.md`。
            *   **操作（关键）**：审查并整合 `.clinerules` `[LEARNING_JOURNAL]`：
                i.  **操作**：从 `.clinerules` 读取当前的 `[LEARNING_JOURNAL]` 部分。
                ii. **目的**：通过分组类似的学习成果、合并相关条目以提高简洁性、删除不是战略或系统级学习的条目（例如，更适合在特定任务期间在 `activeContext.md` 中使用的非常小的战术笔记，或不再相关的临时观察），并确保条目清晰阐述，来精炼日志。
                iii. **流程**：
                    - 识别冗余或涵盖非常相似要点的条目。将它们合并为单个更全面的条目。
                    - 识别过于细粒度或代表临时状态而非持久学习的条目。如果它们的价值不是持久的，考虑删除这些条目。
                    - 识别不适合学习日志目的的条目（例如，简单的提醒、不代表更广泛学习的特定任务笔记）。删除这些条目。
                    - 确保剩余条目清晰、简洁，并真正反映关于 CRCT 过程、项目管理、技术方法或用户交互的重要学习。
                iv. **操作**：将全面审查期间识别的任何*新*重要系统级学习（来自步骤 1e、1f、1g）添加到精炼的日志中。示例："添加到学习日志：清理/整合期间的全面审查揭示了一个反复出现的模式，即当初始数据定义不完整时，任务估计不足，突出了前期需要更严格的数据策略的必要性。"
                v.  **操作**：使用 `write_to_file`（或者如果更适合 `.clinerules` 格式，使用 `apply_diff`）更新 `.clinerules` 中的 `[LEARNING_JOURNAL]` 部分，包含整合的和新添加的条目。

    *   **b. 整合并重组变更日志（关键）**：
        *   **目的**：通过按主要组件/模块构建所有历史条目，然后在每个组件内按时间顺序排列，将 `changelog.md` 转换为更易读和可维护的格式。这为整个项目生命周期提供了清晰、有组织的更改历史。这是长期项目理解和可维护性的**关键**步骤。
        *   **目标**：通过在组件/模块标题下分组条目，在每个组内按时间顺序（最新的在前）排序，来重新格式化 `changelog.md`。
        *   **操作：读取**：使用 `read_file` 加载 `changelog.md` 的当前内容。
        *   **操作：内部处理**：
            1.  **解析条目**：在思想中（或通过概述步骤）将加载的文本解析为单独的变更日志条目（可能由 `---` 或 `### Heading - Date` 分隔）。提取每个条目的日期、摘要、修改文件列表和完整文本块。
            2.  **确定组件**：对于每个条目，根据 `Files Modified` 路径确定其主要组件/模块。使用启发式方法：
                *   如果大多数/所有文件都在 `src/module_name/` 中，组件为 `Module: module_name`。
                *   如果大多数/所有文件都在 `docs/category/` 中，组件为 `Documentation: category`。
                *   如果文件在 `cline_utils/` 或 `cline_docs/` 中，组件为 `CRCT System`。
                *   如果文件跨越多个主要区域，选择最具代表性的一个，或创建一个 `Cross-Cutting` 类别。
                *   如果没有明确的组件可识别，使用默认的 `General` 类别。
            3.  **分组条目**：创建内部列表，按确定的组件对解析的条目进行分组。
            4.  **对组排序**：在每个组件组内，严格按日期（最近的日期在前）对条目进行排序。
            5.  **格式化输出**：为 `changelog.md` 构建*完整的新文本内容*。
                *   从主 `# Changelog` 标题开始。
                *   对于每个组件组：
                    *   添加组件标题（例如，`## Component: Game Loop` 或 `## Documentation: Worldbuilding`）。
                    *   列出该组件的排序条目，保留其原始 `### Summary - Date`、`Description`、`Impact`、`Files Modified` 结构。
                    *   在组件组内的各个条目之间使用 `---`。
                    *   *（可选：如果有助于可读性，在不同组件组之间添加更明显的分隔符，如 `***`）*。
        *   **操作：写入**：使用 `write_to_file` 用上一步生成的*完整的、重新格式化的内容*覆盖 `changelog.md`。
        *   **说明**："重组了 `changelog.md`。读取现有内容，解析条目，按组件分组（例如，Game Loop、Documentation、CRCT System），在每个组内按日期对条目进行排序，并用新结构覆盖文件。"

    *   **c. `activeContext.md`（最后一次检查并关键更新）**：
        *   **操作（关键）**：在所有其他信息都已整合到持久文档（HDTA、核心文件）并且变更日志已重组后，最后一次更新 `activeContext.md`。
        *   **目标**：确保 `activeContext.md` 准确反映*当前、完全整合的整个项目基线状态*。这涉及删除特定于*任何先前完成的工作周期或过时项目状态*的任何瞬态细节（例如，过去任务的逐步执行日志、过时的考虑因素、现在已在其他地方记录的已解决问题）。该文件应仅保留当前的高级项目状态、真正需要立即或近期关注的未解决问题，以及清楚指向详细、持久信息现在所在位置的指针（例如，"功能 Y 的最终设计细节记录在 `implementation_plan_feature_y.md` 中。变更日志已全面重组。下一步关注：基于 `roadmap_v3.md` 的阶段 X。"）。

4.  **MUP**：在完成整合步骤（包括变更日志）后执行核心 MUP 和第 V 节添加。更新 `.clinerules` 中的 `last_action` 以指示整合已完成，清理是下一步。

---

## IV. 清理工作流程

**目标**：删除或归档过时的文件和数据，以减少混乱并保持项目上下文专注于活动工作。**仅在整合（第 III 节）完成后继续。**

**流程：**

1.  **识别清理目标（关键）**：
    *   **关键前提条件**：此步骤完全依赖于第 III 节中执行的全面审查和验证。只有确认为完全完成、已验证且其核心信息已整合到持久文档中的文件才有资格进行清理。
    *   **a. 识别已完成且已整合的任务指令文件**：
        *   参考第 III 节步骤 1e 的结果。任务指令文件满足以下条件：
            i.  已验证为真正完成。
            ii. 其所有关键信息（学习成果、设计选择、"陷阱"）都已成功整合到持久 HDTA 文档或学习日志中。
        *   这些文件是归档的主要候选文件。**在第 III 节步骤 1e 中发现未验证或未完成的任务文件，不得作为 "完成" 项目被清理。**
    *   **b. 识别已实现的策略任务文件**：
        *   参考第 III 节步骤 1f 和 1g 的结果。目标已由下游执行任务（它们本身已验证完成和整合）完全满足，且其自身内容已完全整合的策略任务文件是归档的候选文件。
    *   **c. 识别过时的临时会话文件和追踪器**：
        *   参考第 III 节步骤 1g 的结果。战略追踪文档（路线图、检查清单、审查进度文件）的旧版本，其所有待处理项目和独特有价值的信息都已整合到较新的活动版本（或持久 HDTA 文档）中，是归档的候选文件。
        *   识别任何其他临时会话特定文件（例如，过去阶段的临时笔记，现在已完全处理和整合），这些文件与当前项目状态不再相关。
    *   **d. 识别临时整合笔记文件**：
        *   **操作**：识别 `cline_docs/` 中的 `consolidation_notes.md` 作为整合工作流程（第 III 节）期间创建的临时文件。由于其内容已在第 III 节步骤 3 中完全处理并集成到持久文档中，因此它现在已过时，是归档的候选文件。
    *   **e. 识别其他过时文件**：
        *   考虑在任何项目阶段创建的其他临时文件或日志，确认它们不再相关，并且它们的信息（如果有）已经整合。

2.  **确定清理策略（归档 vs. 删除）**：
    *   **建议**：归档通常比永久删除更安全。
    *   **确定项目根目录**：从当前环境上下文中识别项目根工作区目录的绝对路径。我们将其称为 `{WORKSPACE_ROOT}`。**不要硬编码路径。**
    *   **建议**：如果不存在，建议使用**绝对路径**创建归档结构。
        *   归档目录的绝对路径示例：`{WORKSPACE_ROOT}/cline_docs/archive/tasks/`，`{WORKSPACE_ROOT}/cline_docs/archive/session_trackers/`。
    *   **操作**：首先，如果在前一步中尚未这样做，使用 `list_files` 检查建议的归档目录（例如，`{WORKSPACE_ROOT}/cline_docs/archive/tasks/`，`{WORKSPACE_ROOT}/cline_docs/archive/session_trackers/`）是否已存在。如果不存在，则建议使用 `execute_command` 创建它们。使用绝对路径建议适当的 OS 特定命令（例如，Unix-like 系统的 `mkdir -p`，PowerShell 的 `New-Item -ItemType Directory -Force`，CMD 的 `mkdir`，可能需要先检查是否存在，或者如果已存在则处理错误）。**使用 `ask_followup_question` 确认此特定命令**或允许用户提供替代方案。优先使用环境详细信息来确定用户的 shell，以获得更准确的初始建议。如果目录已存在，则可以跳过此创建步骤。
        ```xml
        <!-- 将工作区根目录确定为 {WORKSPACE_ROOT} -->
        <!-- 建议创建归档目录的命令。 -->
        <ask_followup_question>
          <question>创建归档目录？建议的命令（使用绝对路径，针对检测到的 OS/shell 定制）：
          `[此处的建议命令]`
          此命令对您的 OS/shell 正确吗？</question>
          <follow_up>
            <suggest>是，执行此命令</suggest>
            <suggest>否，我将提供正确的命令</suggest>
          </follow_up>
        </ask_followup_question>
        ```
        *   如果用户选择"是"，则使用建议的命令继续执行 `execute_command`。
        *   如果用户选择"否"，则等待他们的输入，并在 `execute_command` 中使用它。
        *（注意：引用路径是良好的做法，特别是如果根路径可能包含空格。注意多个目录或强制选项的 shell 特定语法。）*

3.  **执行清理（使用 `execute_command`，通过 `ask_followup_question` 获得用户确认）（关键）**：
    *   **输入**：此步骤处理由第 IV 节步骤 1 中严格的验证和整合检查确定为有资格清理（归档或删除）的文件列表，包括 `consolidation_notes.md`。
    *   **列出文件**：使用 `list_files`（使用基于工作区的相对路径）确认来自合格列表的针对清理的文件的当前存在和*相对路径*。
    *   **构建绝对路径**：对于每个为清理识别的相对路径（例如，`tasks/some_task.md`），通过在前面加上确定的 `{WORKSPACE_ROOT}`（例如，`{WORKSPACE_ROOT}/tasks/some_task.md`）来构建其对应的**绝对路径**。对目标归档位置执行相同的操作。
    *   **建议操作并获取命令确认（强制性 `ask_followup_question` 步骤）**：
        *   对于每个文件或要清理的文件组：
            1.  清楚地制定**问题**，说明预期操作（归档/删除）和涉及的完整绝对路径。
            2.  为常见的 OS/shell 组合（Linux/macOS/Git Bash、Windows CMD、Windows PowerShell）生成**建议命令**（作为 `<suggest>` 选项），使用确定的 `{WORKSPACE_ROOT}` 和适当的路径分隔符（`/` 或 `\`）用于每个建议。**优先考虑与检测到的 OS/shell 匹配的建议。**
            3.  包括最后一个 `<suggest>` 选项，如：`提供替代命令`。
            4.  使用带有问题和这些建议的 `ask_followup_question` 工具。
    *   **关于 Shell 准确性的说明**：请注意，检测到的 shell 可能并不总是活动的 shell。如果命令执行失败，请重新验证用户的活动 shell 或要求明确确认。
    *   **示例交互流程**：（示例保持相关，但应定制建议并优先考虑检测到的 shell）
        *   **LLM**：*（基于 `{WORKSPACE_ROOT}` 在内部构建绝对路径）*
          ```xml
          <ask_followup_question>
            <question>将已完成的任务文件 "{WORKSPACE_ROOT}/tasks/Execution_integrate_input_handler_game_loop_task.md" 归档到 "{WORKSPACE_ROOT}/cline_docs/archive/tasks/"？为您的系统选择正确的命令：</question>
            <follow_up>
              <suggest>mv "{WORKSPACE_ROOT}/tasks/Execution_integrate_input_handler_game_loop_task.md" "{WORKSPACE_ROOT}/cline_docs/archive/tasks/"</suggest> <!-- 如果检测到 Linux/macOS，则优先考虑 -->
              <suggest>move "{WORKSPACE_ROOT}\tasks\Execution_integrate_input_handler_game_loop_task.md" "{WORKSPACE_ROOT}\cline_docs\archive\tasks\"</suggest> <!-- 如果检测到 Windows，则优先考虑 -->
              <suggest>提供替代命令</suggest>
            </follow_up>
          </ask_followup_question>
          ```
        *   **用户**：*（选择一个命令或提供替代方案）*
        *   **LLM**："好的，执行所选命令："
          ```xml
          <execute_command>
          <command>[用户确认或提供的命令]</command>
          </execute_command>
          ```
        *   *（等待工具结果，记录操作，然后继续下一个文件）*
    *   **记录操作**：在成功执行后（基于工具输出），清楚地记录使用确认的命令和绝对路径归档或删除了哪些文件。

4.  **最终验证（关键）**：
    *   **操作（关键）**：如果在步骤 3 中执行了任何归档或删除操作，请再次使用 `list_files` 和已处理文件的原始*相对*位置，以验证它们不再存在于这些位置。
    *   **操作（关键）**：确保 `activeContext.md` 是干净的，并且不引用已删除/已归档的文件，除非它明确指向它们的新归档位置以供历史引用。所有其他指针应指向活动的、持久的文档。

5.  **MUP**：在完成清理后执行核心 MUP 和第 V 节添加。更新 `.clinerules` 中的 `last_action` 和 `next_phase` 以表示此阶段的结束。

**清理流程图**
```mermaid
flowchart TD
    A[开始清理（整合后）] --> B[识别清理目标]
    B --> B1[确定绝对工作区根目录 `{WORKSPACE_ROOT}`]
    B1 --> C{归档结构存在？}
    C -- 否 --> D[使用 `ask_followup_question` 确认带绝对路径的 `mkdir` 命令]
    D -- 确认 --> D1[执行确认的 `mkdir` 命令]
    C -- 是 --> E
    D1 --> E
    E --> F[列出目标文件]
    F --> G[对于每个文件/组：]
    G --> G1[为源和目标构建绝对路径]
    G1 --> H[1. 说明意图<br>归档/删除]
    H --> I[2. 生成带绝对路径的 OS 特定命令建议]
    I --> J[3. 使用带建议 + "提供替代方案" 的 `ask_followup_question`]
    J -- 用户选择建议的命令 --> K[通过 `execute_command` 执行所选命令]
    J -- 用户选择 "提供替代方案" --> J1[等待用户命令输入]
    J1 --> K2[通过 `execute_command` 执行用户提供的命令]
    K --> L[记录操作]
    K2 --> L
    L --> M{更多文件？}
    M -- 是 --> G
    M -- 否 --> N[验证文件已移动/删除]
    N --> O[MUP 并更新 .clinerules 以退出阶段]
    O --> P[结束清理]

    style J fill:#f9f,stroke:#f6f,stroke-width:2px,color:#000
    style B1 fill:#e6f7ff,stroke:#91d5ff
    style G1 fill:#fffbe6,stroke:#ffe58f
```

---

## V. 清理/整合插件 - MUP 添加（关键）

**关键**：在适当的时刻，**必须**在核心 MUP 步骤之外执行这些步骤。

1.  **验证 `activeContext.md` 状态（关键）**：在任何重大整合或清理操作之后，特别是在第 III.4 和 IV.5 节中定义的 MUP 点，**关键性**验证 `activeContext.md` 准确反映当前、干净、整合的状态。确保它指向持久文档以获取详细信息，并且所有来自现已完成的周期或过时状态的瞬态信息都已删除。
2.  **验证 `changelog.md` 结构（关键）**：在变更日志重组（第 III.3b 节）之后，以及在第 III.4 节的 MUP 点，**关键性**验证 `changelog.md` 结构正确反映了预期的组件分组和时间顺序排序。
3.  **更新 `.clinerules` [LAST_ACTION_STATE]（关键）**：
    *   **在整合步骤完全完成后（包括变更日志重组 - 按照第 III.4 节）**：
      ```
      [LAST_ACTION_STATE]
      last_action: "Completed ALL Consolidation Steps (incl. Changelog Reorg)"
      current_phase: "Cleanup/Consolidation"
      next_action: "Begin Cleanup Workflow"
      next_phase: "Cleanup/Consolidation"
      ```
    *   **在清理步骤完全完成后（退出阶段 - 按照第 IV.5 节）**：
      ```
      [LAST_ACTION_STATE]
      last_action: "Completed Cleanup/Consolidation Phase (All Steps)"
      current_phase: "Cleanup/Consolidation"
      next_action: "Phase Complete - User Action Required to transition to next phase"
      next_phase: "Set-up/Maintenance" # 或 "Strategy" 或 "Project Complete"
      ```

---

## VI. 快速参考（所有步骤都是关键的）

- **目标**：**关键性且全面地**审查**整个项目状态**。将所有已验证的学习成果、结果和核心信息整合到持久文档。**按组件/日期重组整个项目历史的 `changelog.md`。** 基于严格的验证和整合归档或删除过时文件。
- **顺序**：整合（第 III 节）必须在清理（第 IV 节）之前完全完成。
- **整合（第 III 节）**：
    - **输入（全面审查）**：
        - HDTA 模板（`cline_docs/templates/`）
        - 所有任务指令文件（来自 `tasks/` 和 `cline_docs/archive/`）
        - 所有实施计划文件（来自代码根目录）
        - 所有战略追踪文档（来自 `cline_docs/` 的路线图、检查清单等）
        - 核心状态文件：`activeContext.md`、`changelog.md`（整个历史）、`progress.md`
    - **操作（所有强制性且关键）**：
        1.  审查 HDTA 模板；列出所有任务指令、实施计划、战略追踪器。分批处理≤10 个文件；**将每个批次作为独立任务完全处理**。
        2.  对于所有任务指令：读取、**手动验证结果**（如果结果未验证，更新任务文件及所有引用以显示未完成；未验证的任务不作为完成归档）。提取所有学习成果/设计选择。
        3.  对于所有实施计划：读取、交叉引用任务验证、更新计划状态、提取战略信息。
        4.  对于所有战略追踪器：审查、将旧版本整合到最新版本、根据已验证的任务更新状态。
        5.  从上述审查中识别所有待整合信息。
        6.  更新 HDTA 文档（`system_manifest.md`、`*_module.md`、`implementation_plan_*.md`）。
        7.  更新核心文件：`progress.md`、`userProfile.md`。
        8.  审查、精炼并更新 `.clinerules` `[LEARNING_JOURNAL]`（分组、合并、删除不合适的、添加新的）。
        9.  重组整个 `changelog.md`（解析->按组件分组->按日期排序->格式化->写入）。
        10. 更新 `activeContext.md` 以反映完全整合的项目基线。
    - **工具**：`list_files`、`read_file`、`write_to_file`、`apply_diff`。
- **清理（第 IV 节）**：
    - **输入（来自第 III 节）**：已验证的完全完成且已整合的任务指令列表；已实现的策略任务；过时的（完全整合的）会话文件/追踪器；其他确认的过时文件。
    - **操作（所有强制性且关键）**：
        1.  **基于第 III 节的已验证输出**识别清理目标。
        2.  确定归档策略（首选归档）；检查/创建归档目录（使用 `ask_followup_question` 确认命令）。
        3.  对于每个合格文件：构建绝对路径、使用 `ask_followup_question` 确认归档/删除命令、执行、记录。
        4.  验证文件已移动/删除（使用 `list_files`）；确保 `activeContext.md` 干净。
    - **工具**：`list_files`、`execute_command`、`ask_followup_question`。
- **MUP 添加（第 V 节）（关键）**：
    - 整合后：验证 `activeContext.md`、`changelog.md`；更新 `.clinerules`（last_action："Completed ALL Consolidation..."，next_action："Begin Cleanup..."）。
    - 清理后（退出阶段）：验证 `activeContext.md`；更新 `.clinerules`（last_action："Completed Cleanup/Consolidation Phase (All Steps)..."，next_action："Phase Complete..."）。
