# **Cline 递归思维链系统 (CRCT) - 清理/整合插件**

**此插件提供 CRCT 系统清理/整合阶段的详细说明和流程。应与核心系统提示配合使用。**

---

## I. 进入和退出清理/整合阶段

**进入清理/整合阶段：**
1. **`.clinerules` 检查**：始终首先读取 `.clinerules`。如果 `[LAST_ACTION_STATE]` 显示 `next_phase: "Cleanup/Consolidation"`，则按这些说明继续。此阶段通常跟随在执行阶段之后。
2. **用户触发**：如果系统在执行后暂停，等待此阶段，则启动新会话。

**退出清理/整合阶段：**
1. **完成标准：**
   - 整合步骤（第三节）已完成：相关信息已整合到持久文档中，变更日志已重新组织。
   - 清理步骤（第四节）已完成：过时文件已识别并归档/删除。
   - `activeContext.md` 反映干净的整合状态。
   - 所有操作都遵循 MUP。
2. **`.clinerules` 更新 (MUP)：**
   - 通常转换回设置/维护进行验证，或转换到策略以进行下一个规划周期：
     ```
     [LAST_ACTION_STATE]
     last_action: "Completed Cleanup/Consolidation Phase"
     current_phase: "Cleanup/Consolidation"
     next_action: "Phase Complete - User Action Required"
     next_phase: "Set-up/Maintenance" # 如果立即规划下一个周期，则为 "Strategy"
     ```
   - *替代方案：如果项目现在被视为完全完成：*
     ```
     [LAST_ACTION_STATE]
     last_action: "Completed Cleanup/Consolidation Phase - Project Finalized"
     current_phase: "Cleanup/Consolidation"
     next_action: "Project Completion - User Review"
     next_phase: "Project Complete"
     ```
3. **用户操作**：更新 `.clinerules` 后，暂停等待用户触发下一阶段。

---

## II. 阶段目标

**目标**：系统地审查执行周期后的项目状态，将关键信息和学习整合到持久文档（HDTA、核心文件）中，**重新组织变更日志以提高可读性**，并清理临时或过时文件（如已完成的任务说明、会话跟踪器和临时整合笔记），以保持专注和相关的项目上下文。

**工作流顺序**：整合必须在清理*之前*进行。

---

## III. 整合工作流

**目标**：将最近执行周期中的关键信息、决策和学习综合到核心项目文档中，并按组件/模块重新组织变更日志。

<<<***关键警告***>>>
*您**必须**通过手动读取基础文件的状态来验证完成状态。对于代码文件，读取实际代码。对于文档，读取相关文档。*

**流程：**

1. **审查和验证所有相关项目文档和任务状态（关键）**：
    * **a. 识别 HDTA 文档结构和其他战略跟踪器**：
        - **操作**：审查 `cline_docs/templates/` 中的文件，以了解所有 HDTA 文档层级的标准结构和预期内容（`system_manifest.md`、`*_module.md`、`implementation_plan_*.md`、`task_instruction.md`）。
        - **操作**：使用 `list_files` 在 `cline_docs/` 中（如果使用自定义位置，可能是其他相关项目文档目录）搜索匹配 `*roadmap*.md`、`*checklist*.md`、`*review_progress*.md` 或其他战略跟踪文档模式的任何文件。
        - **目的**：确保完全理解项目的预期文档结构，并识别需要审查和整合的所有高层级跟踪文档。
    * **b. 列出所有任务说明文件**：
        - **操作**：使用 `list_files` 递归识别主 `tasks/` 目录（及其子目录）中的所有 `*.md` 文件。
        - **操作**：使用 `list_files` 递归识别*整个* `cline_docs/archive/` 目录（及其子目录）中的所有 `*.md` 文件，以定位任何先前归档的任务文件。
        - **目的**：创建所有可用任务说明文件的综合列表，无论其当前位置（活动或已归档），以便后续分批审查。
    * **c. 列出所有实施计划文件**：
        - **操作**：对于 `[CODE_ROOT_DIRECTORIES]` 中列出的每个目录（来自 `.clinerules`），使用 `list_files` 递归识别匹配模式 `implementation_plan_*.md` 的所有文件。这些通常位于模块目录内（例如 `src/module_name/implementation_plan_*.md`）。
        - **目的**：创建所有实施计划文件的综合列表，以便后续分批审查。
    * **d. 读取核心项目状态文件**：
        - **操作**：读取 `activeContext.md`：识别关键决策、未解决的问题和已完成工作的摘要。
        - **操作**：读取 `changelog.md`：审查所有重大变更。**（注意：将在步骤 3 中重新组织）**。
        - **操作**：读取 `progress.md`：检查所有高层级里程碑。
        - **目的**：收集当前项目状态信息，将用于整合流程。
    * **e. 分批审查所有已识别的任务说明文件（关键）**：
        - **目的**：识别重要的实施细节、设计选择、"注意事项"、学习，并**关键地验证任务的实际完成状态**。此审查涵盖步骤 1b 中识别的所有任务说明文件，分批处理以防止上下文过载。
        - **流程**：
            i. **批次创建**：
                - **操作**：将任务说明文件的综合列表（来自步骤 1b）分成批次，每批次包含**不超过 10 个文件**。如果文件总数不能被 10 整除，最后一批可能包含少于 10 个文件。
                - **操作**：维护已处理文件的记录，以确保没有文件被遗漏或重复处理。这可以在内部完成，或通过更新临时跟踪机制（例如，在此阶段期间在 `activeContext.md` 中添加注释）来完成。
            ii. **处理每个批次（独立处理）**：
                - **操作**：对于每批最多 10 个任务说明文件，在继续下一批次之前**将批次作为独立任务完全处理**。这意味着完成批次中所有文件的所有验证、提取和更新操作，批次之间没有这些操作的相互依赖关系。
                - **子流程（对于批次中的每个文件）**：
                    1. **读取任务文件**：
                        - **操作**：使用 `read_file` 读取任务文件的内容。
                    2. **验证完成（手动和关键）**：
                        - **验证方法**：
                            - 对于**执行任务**：如果任务文件指示对项目工件采取了具体操作（例如"将 x 应用于 y"、"创建文件 z"、"修改文件 w 中的函数 f"、"更新文档 q"），您**必须**通过检查目标工件来手动验证此结果。
                            - 对于**策略任务**：验证涉及确认策略任务的预期输出（例如设计文档、研究摘要、一组定义的需求、已完成的探索）已产生、完成并满足任务目标。这可能涉及读取输出文档或评估任务文件本身中呈现的策略分析的完整性。
                        - **操作**：使用 `read_file` 检查目标工件或输出文档，或根据需要使用 `list_files` 确认存在/修改。如果它们提供与任务相关的具体文件修改详细信息，请查阅 `changelog.md` 条目。
                        - **如果结果未验证**（例如 'x' 未应用于 'y'，文件 'z' 不包含预期内容，函数 'f' 未按描述修改）：
                            - 明确记录此任务文件的差异。
                            - **操作（关键）**：如果任务文件有"状态：已完成"标记（或其所有内部步骤都已勾选暗示完成），则此状态现在被视为**无效**。您**必须**更新任务文件本身以删除或清楚地将"已完成"状态标记为不正确/未验证（例如更改为"状态：待验证"或"状态：未完成 - 结果未验证"）。
                            - **操作（关键）**：识别所有将此任务引用为已完成的文档。这包括（但不限于）父实施计划、任何 `*checklist*.md` 文件、`*roadmap*.md` 文件、`progress.md`，以及可能还有 `activeContext.md`。更新这些引用文档以反映任务的真实（未验证/未完成）状态。
                            - **注意**：此任务文件**不得**在第四节中作为"完成"归档。可能需要在后续阶段创建新任务来解决未完成的问题。
                    3. **提取可整合信息（关键）**：
                        - 无论验证完成状态如何，识别任务文件*内部*记录的任何设计决策、新信息、重要学习、"注意事项"或与原始计划的偏差。
                        - **操作**：将这些信息记录在位于 `cline_docs/` 的临时文件 `consolidation_notes.md` 中。在每条信息后附加对源文件和批次的引用（例如"批次 1，task_abc.md：了解到算法 X 对大型数据集来说次优"）。使用 `write_to_file` 或 `apply_diff` 更新 `consolidation_notes.md`。
                - **操作**：在完全处理当前批次中的所有文件后（即所有文件都已读取、在必要时更新，并且它们可整合的信息已记录在 `consolidation_notes.md` 中），在 `activeContext.md` 中记录批次的完成（例如"完成批次 X 中文件 [file1, file2, ...] 的验证和提取。信息已记录在 `consolidation_notes.md` 中"）。只有这样才继续下一批次。
                - **目的**：将每个批次作为独立任务处理，确保所有关键操作都在不依赖未来的批次的情况下完成，从而减少上下文过载，同时保持全面的验证和提取。
    * **f. 分批审查所有已识别的实施计划文件（关键）**：
        - **目的**：整合战略决策、结果，并确保与已完成（和已验证）任务保持一致。此审查涵盖步骤 1c 中识别的所有文件，分批处理以防止上下文过载。
        - **流程**：
            i. **批次创建**：
                - **操作**：将实施计划文件的综合列表（来自步骤 1c）分成批次，每批次包含**不超过 10 个文件**。如果文件总数不能被 10 整除，最后一批可能包含少于 10 个文件。
                - **操作**：维护已处理文件的记录，以确保没有文件被遗漏或重复处理。
            ii. **处理每个批次（独立处理）**：
                - **操作**：对于每批最多 10 个实施计划文件，在继续下一批次之前**将批次作为独立任务完全处理**。这意味着完成批次中所有文件的所有读取、分析、更新和提取操作，批次之间没有这些操作的相互依赖关系。
                - **子流程（对于批次中的每个文件）**：
                    1. **读取实施计划**：
                        - **操作**：使用 `read_file` 读取实施计划的内容。
                    2. 识别计划中描述的任何高层级战略决策、架构变更或总体结果。
                    3. 根据步骤 1e 确定的验证状态，交叉引用计划中列出的任务。更新实施计划以准确反映其子任务的真实完成状态。
                    4. **提取可整合信息**：
                        - 标记尚未在更高层级 HDTA 文档（如 `system_manifest.md` 或 `*_module.md` 文件）中捕获的任何重要战略信息。
                        - **操作**：将这些信息记录在 `cline_docs/` 中的 `consolidation_notes.md` 中，附加对源文件和批次的引用（例如"批次 2，implementation_plan_feature_y.md：决定使用微服务以提高可扩展性"）。
                - **操作**：在完全处理当前批次中的所有文件后（即所有文件都已读取、更新，并且它们可整合的信息已记录在 `consolidation_notes.md` 中），在 `activeContext.md` 中记录批次的完成（例如"完成批次 Y 中实施计划 [plan1, plan2, ...] 的验证和提取。信息已记录在 `consolidation_notes.md` 中"）。只有这样才继续下一批次。
                - **目的**：将每个批次作为独立任务处理，确保实施计划的可管理处理，与已验证的任务状态保持一致。
    * **g. 分批审查其他战略跟踪文档（路线图、检查清单等）（关键）**：
        - **目的**：确保所有高层级跟踪文档都是最新的，并且不会丢失旧版本中未完成的项目。此审查涵盖步骤 1a 中识别的所有文件（HDTA 模板除外），分批处理以防止上下文过载。
        - **流程**：
            i. **批次创建**：
                - **操作**：将战略跟踪文档的综合列表（来自步骤 1a，例如 `*roadmap*.md`、`*checklist*.md`、`*review_progress*.md`）分成批次，每批次包含**不超过 10 个文件**。如果文件总数不能被 10 整除，最后一批可能包含少于 10 个文件。
                - **操作**：维护已处理文件的记录，以确保没有文件被遗漏或重复处理。
            ii. **处理每个批次（独立处理）**：
                - **操作**：对于每批最多 10 个战略跟踪文档，在继续下一批次之前**将批次作为独立任务完全处理**。这意味着完成批次中所有文件的所有读取、整合、更新和提取操作，批次之间没有这些操作的相互依赖关系。
                - **子流程（对于批次中的每个文件）**：
                    1. 如果同一概念跟踪器的多个版本存在（例如 `project_checklist_v1.md`、`project_checklist_v2.md`）：
                        - **操作**：读取批次中的所有版本。
                        - **操作（关键）**：识别*最新*版本。将*旧*版本中所有未完成或待处理的项目整合到此最新版本中。
                        - **操作（关键）**：确保旧版本中记录的所有重要已完成项目和学习适当地反映在持久项目文档（HDTA、变更日志等）中，或者如果与上下文仍然相关，则转移到最新跟踪器版本。
                        - 一旦旧版本完全整合（其所有独特的、仍然相关的信息都已转移），就可以考虑在第四节中归档。最新版本成为活动跟踪器。
                    2. 对于每个跟踪器的活动/最新版本，根据已验证的任务状态（来自步骤 1e）和实施计划审查（步骤 1f）审查其项目。更新跟踪器以准确反映项目进度。
                    3. **提取可整合信息**：
                        - 标记用于更广泛整合的战略洞察或状态更新（例如，到 `activeContext.md` 或 `progress.md`）。
                        - **操作**：将这些信息记录在 `cline_docs/` 中的 `consolidation_notes.md` 中，附加对源文件和批次的引用（例如"批次 3，roadmap_v3.md：根据任务延迟更新里程碑优先级"）。
                - **操作**：在完全处理当前批次中的所有文件后（即所有文件都已读取、整合、更新，并且它们可整合的信息已记录在 `consolidation_notes.md` 中），在 `activeContext.md` 中记录批次的完成（例如"完成批次 Z 中跟踪器 [tracker1, tracker2, ...] 的验证和提取。信息已记录在 `consolidation_notes.md` 中"）。只有这样才继续下一批次。
                - **目的**：将每个批次作为独立任务处理，确保战略跟踪器的可管理处理，保持全面整合。

2. **识别所有需要整合的信息（关键）**：
    - 基于步骤 1 中进行的全面审查（涵盖所有任务说明、实施计划、战略跟踪器和核心状态文件），**关键地**列出所有代表持久设计决策、架构变更、重大结果、完善的需求、重要操作学习、"注意事项"或任何其他关键知识的特定信息片段，这些**必须**整合到持久项目文档中。此列表不仅限于最近操作周期的发现，而是涵盖审查的整个项目历史。（此步骤不包括变更日志结构重组，该重组在步骤 3b 中处理）。

3. **更新持久文档并重新组织变更日志**：

    * **a. 更新标准文档（HDTA、核心文件）（关键）**：
        - **目的**：确保所有持久项目文档准确反映从步骤 2 中的 `consolidation_notes.md` 收集的整合知识。这是**关键**步骤，用于维护项目的最新和可靠的知识库。
        - **HDTA 文档**：
            - **操作（关键）**：如果整体架构、核心组件或项目目标在任何时候有演变或澄清，则更新 `system_manifest.md`。
            - **操作（关键）**：更新相关域模块（`*_module.md`）以纳入完善的描述、接口变更、关键实施说明或发现的任何其他重要学习。
            - **操作（关键）**：使用最终结果说明、与原始计划的偏差或任何实施过程中做出的重大决策更新相关实施计划（`implementation_plan_*.md`）。确保它们准确反映其子任务的已验证完成状态。
            - **流程**：对于每个需要更新的 HDTA 文档：使用 `read_file` 加载目标文档，逻辑清晰地整合整合信息，并使用 `write_to_file` 保存更改。**说明每次更新的推理，引用整合信息的来源（例如，特定任务文件、`activeContext.md` 洞察）。** 例如："将模块 Y 的最终算法选择（来自已归档任务 `cline_docs/archive/tasks/task_abc.md`）整合到 `src/module_y/module_y_module.md` 中。"
        - **核心文件**：
            - **操作（关键）**：根据已验证的结果准确标记所有已完成的高层级检查清单项目，更新 `progress.md`。
            - **操作（关键）**：使用任何新观察到或强化的用户偏好或交互模式更新 `userProfile.md`。
            - **操作（关键）**：审查和整合 `.clinerules` `[LEARNING_JOURNAL]`：
                i. **操作**：从 `.clinerules` 读取当前的 `[LEARNING_JOURNAL]` 部分。
                ii. **目的**：通过分组相似的学习、组合相关条目以简洁性、删除不适合战略或系统级学习的条目（例如，更适合特定任务期间的 `activeContext.md` 的非常次要的战术笔记，或不再相关的临时观察），并确保条目清晰表达来完善日志。
                iii. **流程**：
                    - 识别冗余或涵盖非常相似点的条目。将它们组合成一个更全面的条目。
                    - 识别过于细化或代表临时状态而非持久学习的条目。如果其价值不持久，请考虑删除这些条目。
                    - 识别不适合学习日志目的的条目（例如，简单提醒、不代表更广泛学习的任务特定笔记）。删除这些。
                    - 确保剩余条目清晰、简洁，并真正反映关于 CRCT 流程、项目管理、技术方法或用户交互的重大学习。
                iv. **操作**：在全面审查期间（来自步骤 1e、1f、1g）识别的任何*新*重大系统级学习添加到完善的日志中。例如："添加到学习日志：清理/整合期间的全面审查显示，当初始数据定义不完整时，会出现任务低估的反复模式，强调了前期需要更严格的数据策略。"
                v. **操作**：使用 `write_to_file`（或如果更适合 `.clinerules` 格式，则使用 `apply_diff`）用整合和新添加的条目更新 `.clinerules` 中的 `[LEARNING_JOURNAL]` 部分。

    * **b. 整合和重新组织变更日志（关键）**：
        - **目的**：通过将所有历史条目按其主要组件/模块分组，然后在每个组件内按时间顺序排序，将 `changelog.md` 转换为更易读和可维护的格式。这提供了整个项目生命周期的清晰、有组织的变更历史。这是**关键**步骤，用于长期项目理解和可维护性。
        - **目标**：通过在组件/模块标题下分组条目来重新格式式 `changelog.md`，在每个组内按时间顺序排序（最新的在前）。
        - **操作：读取**：使用 `read_file` 加载 `changelog.md` 的当前内容。
        - **操作：内部处理**：
            1. **解析条目**：在心理上（或通过概述步骤）将加载的文本解析为单个变更日志条目（可能由 `---` 或 `### 标题 - 日期` 分隔）。提取每个条目的日期、摘要、文件修改列表和完整文本块。
            2. **确定组件**：对于每个条目，基于 `文件修改` 路径确定其主要组件/模块。使用启发式方法：
                - 如果大多数/所有文件都在 `src/module_name/` 中，组件为 `模块：module_name`。
                - 如果大多数/所有文件都在 `docs/category/` 中，组件为 `文档：category`。
                - 如果文件在 `cline_utils/` 或 `cline_docs/` 中，组件为 `CRCT 系统`。
                - 如果文件跨越多个主要区域，选择最具代表性的一个或创建 `跨领域` 类别。
                - 如果没有可识别的清晰组件，则使用默认的 `常规` 类别。
            3. **分组条目**：创建内部列表，按其确定的组件对解析的条目进行分组。
            4. **排序组**：在每个组件组内，严格按日期（最新日期在前）对条目进行排序。
            5. **格式化输出**：为 `changelog.md` 构建*整个新文本内容*。
                - 从主 `# 变更日志` 标题开始。
                - 对于每个组件组：
                    - 添加组件标题（例如 `## 组件：游戏循环` 或 `## 文档：世界构建`）。
                    - 列出该组件的排序条目，保留其原始的 `### 摘要 - 日期`、`描述`、`影响`、`文件修改` 结构。
                    - 在组件组内的单个条目之间使用 `---`。
                - *（可选：如果有助于可读性，在不同组件组之间添加更明显的分隔符，如 `***`）*。
        - **操作：写入**：使用 `write_to_file` 用上一步生成的*完整、重新格式化的内容*覆盖 `changelog.md`。
        - **状态**："重新组织了 `changelog.md`。读取现有内容，解析条目，按组件（例如游戏循环、文档、CRCT 系统）分组，在每个组内按日期排序，并用新结构覆盖文件。"

    * **c. `activeContext.md`（最后传递和关键更新）**：
        - **操作（关键）**：在所有其他信息已整合到持久文档（HDTA、核心文件）中并且变更日志已重新组织后，最后更新一次 `activeContext.md`。
        - **目标**：确保 `activeContext.md` 准确反映*当前、完全整合的项目整体基线状态*。这包括删除*任何先前完成的工作周期或过时项目状态*的任何瞬时细节（例如，过去任务的逐步执行日志、过时的考虑、现在已在其他地方记录的已解决问题）。文件应仅保留当前高层级项目状态、真正需要立即或近期注意的突出问题的清晰指针，以及指向详细、持久信息现在所在位置的指针（例如"功能 Y 的最终设计细节记录在 `implementation_plan_feature_y.md` 中。变更日志已全面重新组织。下一步：基于 `roadmap_v3.md` 的阶段 X。"）。

4. **MUP**：在完成整合步骤（包括变更日志）后执行核心 MUP 和第五节添加。更新 `.clinerules` 中的 `last_action` 以指示整合已完成，接下来是清理。

---

## IV. 清理工作流

**目标**：删除或归档过时文件和数据以减少杂乱，并保持项目上下文专注于活动工作。**仅在整合（第三节）完成后继续。**

**流程：**

1. **识别清理目标（关键）**：
    - **关键前置条件**：此步骤完全依赖于第三节中进行的全面审查和验证。只有被确认为完全完成、验证并且其所有关键信息已整合到持久文档中的文件才有资格进行清理。
    * **a. 识别已完成和整合的任务说明文件**：
        - 参考第三节步骤 1e 的结果。满足以下条件的任务说明文件：
            i. 已验证为真正完成。
            ii. 其所有关键信息（学习、设计选择、"注意事项"）已成功整合到持久 HDTA 文档或学习日志中。
        - 这些文件是主要的归档候选。**在第三节步骤 1e 中发现未验证或未完成的任务文件不得作为"完成"项目进行清理。**
    * **b. 识别已履行的策略任务文件**：
        - 参考第三节步骤 1f 和 1g 的结果。其目标已由下游执行任务（本身已验证完成和整合）完全满足，并且其自身内容已完全整合的策略任务文件是归档的候选。
    * **c. 识别过时的临时会话文件和跟踪器**：
        - 参考第三节步骤 1g 的结果。旧版本的战略跟踪文档（路线图、检查清单、审查进度文件），如果其所有待处理项目和独特有价值的信息都已整合到较新的活动版本（或持久 HDTA 文档）中，则为归档的候选。
        - 识别任何其他临时会话特定文件（例如，过去阶段的临时笔记，现已完全处理和整合），这些文件与当前项目状态不再相关。
    * **d. 识别临时整合笔记文件**：
        - **操作**：将 `cline_docs/` 中的 `consolidation_notes.md` 识别为在整合工作流（第三节）期间创建的临时文件。由于其内容已在第三节步骤 3 中完全处理并整合到持久文档中，因此现在已过时，是归档的候选。
    * **e. 识别其他过时文件**：
        - 考虑任何其他临时文件或日志，如果它们在任何项目阶段期间创建，并确认不再相关，并且其信息（如果有）已整合。

2. **确定清理策略（归档 vs. 删除）**：
    - **建议**：归档通常比永久删除更安全。
    - **确定项目根目录**：从当前环境上下文中识别项目根工作区目录的绝对路径。让我们称之为 `{WORKSPACE_ROOT}`。**不要硬编码路径。**
    - **提案**：提出创建归档结构（如果不存在），使用**绝对路径**。
        - 归档目录的绝对路径示例：`{WORKSPACE_ROOT}/cline_docs/archive/tasks/`、`{WORKSPACE_ROOT}/cline_docs/archive/session_trackers/`。
    - **操作**：首先，使用 `list_files` 检查建议的归档目录（例如 `{WORKSPACE_ROOT}/cline_docs/archive/tasks/`、`{WORKSPACE_ROOT}/cline_docs/archive/session_trackers/`）是否已经存在（如果您在先前的步骤中尚未这样做）。如果不存在，则提出使用 `execute_command` 创建它们。提出适当的操作系统特定命令（例如，Unix-like 的 `mkdir -p`，PowerShell 的 `New-Item -ItemType Directory -Force`，CMD 的 `mkdir` 可能需要先检查存在性或处理已存在的错误），使用绝对路径。**使用 `ask_followup_question` 确认此特定命令**或允许用户提供替代方案。优先使用环境详细信息来确定用户的 shell，以进行更准确的初始建议。如果目录已存在，则可以跳过此创建步骤。
        ```xml
        <!-- 确定工作区根目录为 {WORKSPACE_ROOT} -->
        <!-- 提出创建归档目录的命令。 -->
        <ask_followup_question>
          <question>创建归档目录？建议的命令（使用绝对路径，针对检测到的操作系统/shell 定制）：
          `[此处为建议的命令]`
          此命令对您的操作系统/shell 是否正确？</question>
          <follow_up>
            <suggest>是，执行此命令</suggest>
            <suggest>否，我将提供正确的命令</suggest>
          </follow_up>
        </ask_followup_question>
        ```
        - 如果用户选择"是"，继续使用 `execute_command` 执行建议的命令。
        - 如果用户选择"否"，等待他们的输入并在 `execute_command` 中使用该输入。
        *（注意：引用路径是好的做法，特别是如果根路径可能包含空格。请注意特定 shell 的多个目录或强制选项的语法。）*

3. **执行清理（使用 `execute_command` 通过 `ask_followup_question` 进行用户确认）（关键）**：
    - **输入**：此步骤处理根据第四节步骤 1 中的严格验证和整合检查被认为符合清理（归档或删除）条件的文件列表，包括 `consolidation_notes.md`。
    - **列出文件**：使用 `list_files`（使用基于工作区的相对路径）确认来自*合格列表*的清理目标的当前存在性和*相对路径*。
    - **构造绝对路径**：对于识别为清理的每个相对路径（例如 `tasks/some_task.md`），通过前缀确定的 `{WORKSPACE_ROOT}` 来构造其相应的**绝对路径**（例如 `{WORKSPACE_ROOT}/tasks/some_task.md`）。对目标归档位置执行相同的操作。
    - **提出操作并获取命令确认（强制性 `ask_followup_question` 步骤）**：
        - 对于要清理的每个文件或文件组：
            1. 清楚地阐明**问题**，说明预期操作（归档/删除）和所涉及的完整绝对路径。
            2. 为常见操作系统/shell 组合（Linux/macOS/Git Bash、Windows CMD、Windows PowerShell）生成**建议命令**（作为 `<suggest>` 选项），使用确定的 `{WORKSPACE_ROOT}` 和每个建议的适当路径分隔符（`/` 或 `\`）。**优先选择与检测到的操作系统/shell 匹配的建议。**
            3. 包括最后的 `<suggest>` 选项，如：`提供替代命令`。
            4. 使用带有问题和建议的 `ask_followup_question` 工具。
    - **关于 Shell 准确性的说明**：请注意，检测到的 shell 可能并不总是活动的。如果命令执行失败，请重新验证用户的活动的 shell 或要求明确确认。
    - **示例交互流程**：（示例仍然相关，但建议应根据检测到的 shell 定制并优先）
        - **LLM**：*（基于 `{WORKSPACE_ROOT}` 内部构造绝对路径）*
          ```xml
          <ask_followup_question>
            <question>将已完成的任务文件 "{WORKSPACE_ROOT}/tasks/Execution_integrate_input_handler_game_loop_task.md" 归档到 "{WORKSPACE_ROOT}/cline_docs/archive/tasks/"？为您的系统选择正确的命令：</question>
            <follow_up>
              <suggest>mv "{WORKSPACE_ROOT}/tasks/Execution_integrate_input_handler_game_loop_task.md" "{WORKSPACE_ROOT}/cline_docs/archive/tasks/"</suggest> <!-- 如果检测到 Linux/macOS 则优先 -->
              <suggest>move "{WORKSPACE_ROOT}\tasks\Execution_integrate_input_handler_game_loop_task.md" "{WORKSPACE_ROOT}\cline_docs\archive\tasks\"</suggest> <!-- 如果检测到 Windows 则优先 -->
              <suggest>提供替代命令</suggest>
            </follow_up>
          </ask_followup_question>
          ```
        - **用户**：*（选择命令或提供替代方案）*
        - **LLM**："好的，执行选定的命令："
          ```xml
          <execute_command>
          <command>[用户确认或提供的命令]</command>
          </execute_command>
          ```
        - *（等待工具结果，记录操作，然后继续下一个文件）*
    - **记录操作**：成功执行后（基于工具输出），使用确认的命令和绝对路径清楚记录哪些文件已归档或删除。

4. **最终验证（关键）**：
    - **操作（关键）**：如果在步骤 3 中执行了任何归档或删除操作，再次使用 `list_files` 和已处理文件的原始*相对*位置来验证它们不再存在于这些位置。
    - **操作（关键）**：确保 `activeContext.md` 是干净的，并且不引用已删除/归档的文件，除非它明确指向它们的新归档位置以供历史参考。所有其他指针应指向活动的、持久的文档。

5. **MUP**：在完成清理后执行核心 MUP 和第五节添加。更新 `.clinerules` 中的 `last_action` 和 `next_phase` 以表示阶段结束。

**清理流程图**
```mermaid
flowchart TD
    A[开始清理（整合后）] --> B[识别清理目标]
    B --> B1[确定绝对工作区根目录 `{WORKSPACE_ROOT}`]
    B1 --> C{归档结构是否存在？}
    C -- 否 --> D[使用 `ask_followup_question` 确认 `mkdir` 命令及绝对路径]
    D -- 已确认 --> D1[执行确认的 `mkdir` 命令]
    C -- 是 --> E
    D1 --> E
    E --> F[列出目标文件]
    F --> G[对于每个文件/组：]
    G --> G1[为源和目标构造绝对路径]
    G1 --> H[1. 阐明意图<br>归档/删除]
    H --> I[2. 生成带有绝对路径的操作系统特定命令建议]
    I --> J[3. 使用 `ask_followup_question` 及建议 + "提供替代方案"]
    J -- 用户选择建议命令 --> K[通过 `execute_command` 执行选定命令]
    J -- 用户选择"提供替代方案" --> J1[等待用户命令输入]
    J1 --> K2[通过 `execute_command` 执行用户提供的命令]
    K --> L[记录操作]
    K2 --> L
    L --> M{更多文件？}
    M -- 是 --> G
    M -- 否 --> N[验证文件已移动/删除]
    N --> O[MUP 并更新 .clinerules 以退出阶段]
    O --> P[结束清理]

    style J fill:#f9f,stroke:#f6f,stroke-width:2px,color:#000
    style B1 fill:#e6f7ff,stroke:#91d5ff
    style G1 fill:#fffbe6,stroke:#ffe58f
```

---

## V. 清理/整合插件 - MUP 添加（关键）

**关键**：这些步骤**必须**在适当的结合点除核心 MUP 步骤外执行。

1. **验证 `activeContext.md` 状态（关键）**：在任何重大整合或清理操作后，特别是在第三节.4 和第四节.5 中定义的 MUP 点，**关键地**验证 `activeContext.md` 准确反映当前、干净和整合的状态。确保它指向持久文档以获取详细信息，并且所有来自现已完成周期或过时状态的瞬时信息都已被删除。
2. **验证 `changelog.md` 结构（关键）**：在变更日志重新组织（第三节.3b）后，以及在第三节.4 中的 MUP 点，**关键地**验证 `changelog.md` 结构是否正确反映预期的组件分组和时间顺序排序。
3. **更新 `.clinerules` [LAST_ACTION_STATE]（关键）**：
    - **整合步骤完全完成后（包括变更日志重新组织 - 根据第三节.4）**：
      ```
      [LAST_ACTION_STATE]
      last_action: "Completed ALL Consolidation Steps (incl. Changelog Reorg)"
      current_phase: "Cleanup/Consolidation"
      next_action: "Begin Cleanup Workflow"
      next_phase: "Cleanup/Consolidation"
      ```
    - **清理步骤完全完成后（退出阶段 - 根据第四节.5）**：
      ```
      [LAST_ACTION_STATE]
      last_action: "Completed Cleanup/Consolidation Phase (All Steps)"
      current_phase: "Cleanup/Consolidation"
      next_action: "Phase Complete - User Action Required to transition to next phase"
      next_phase: "Set-up/Maintenance" # 或 "Strategy" 或 "Project Complete"
      ```

---

## VI. 快速参考（所有步骤都是关键）

- **目标**：**关键地**和全面地审查**整个项目状态**。将所有已验证的学习、结果和关键信息整合到持久文档中。**按组件/日期重新组织整个项目历史的 `changelog.md`。** 基于严格验证和整合归档或删除过时文件。
- **顺序**：整合（第三节）必须在清理（第四节）之前完全完成。
- **整合（第三节）**：
    - **输入（全面审查）**：
        - HDTA 模板（`cline_docs/templates/`）
        - 所有任务说明文件（来自 `tasks/` 和 `cline_docs/archive/`）
        - 所有实施计划文件（来自代码根目录）
        - 所有战略跟踪文档（路线图、检查清单，来自 `cline_docs/` 等）
        - 核心状态文件：`activeContext.md`、`changelog.md`（整个历史）、`progress.md`
    - **操作（所有强制和关键）**：
        1. 审查 HDTA 模板；列出所有任务说明、实施计划、战略跟踪器。以 ≤10 个文件的批次处理；**将每个批次作为独立任务完全处理**。
        2. 对于所有任务说明：读取，**手动验证结果**（如果结果未验证，更新任务文件和所有引用以显示未完成；未验证的任务不得作为完成归档）。提取所有学习/设计选择。
        3. 对于所有实施计划：读取、交叉引用任务验证，更新计划状态，提取战略信息。
        4. 对于所有战略跟踪器：审查，将旧版本整合到最新版本，基于已验证任务更新状态。
        5. 从上述审查中识别所有需要整合的信息。
        6. 更新 HDTA 文档（`system_manifest.md`、`*_module.md`、`implementation_plan_*.md`）。
        7. 更新核心文件：`progress.md`、`userProfile.md`。
        8. 审查、完善和更新 `.clinerules` `[LEARNING_JOURNAL]`（分组、组合、删除不适当的、添加新的）。
        9. 重新组织整个 `changelog.md`（解析->按组件分组->按日期排序->格式化->写入）。
        10. 更新 `activeContext.md` 以反映完全整合的项目基线。
    - **工具**：`list_files`、`read_file`、`write_to_file`、`apply_diff`。
- **清理（第四节）**：
    - **输入（来自第三节）**：完全完成和整合的任务说明的已验证列表；已履行的策略任务；过时的（完全整合）会话文件/跟踪器；其他确认的过时文件。
    - **操作（所有强制和关键）**：
        1. 基于第三节的已验证输出识别清理目标。
        2. 确定归档策略（首选归档）；检查/创建归档目录（通过 `ask_followup_question` 确认命令）。
        3. 对于每个符合条件的文件：构造绝对路径，通过 `ask_followup_question` 确认归档/删除命令，执行，记录。
        4. 验证文件已移动/删除（使用 `list_files`）；确保 `activeContext.md` 是干净的。
    - **工具**：`list_files`、`execute_command`、`ask_followup_question`。
- **MUP 添加（第五节）（关键）**：
    - 整合后：验证 `activeContext.md`、`changelog.md`；更新 `.clinerules`（last_action: "Completed ALL Consolidation..."，next_action: "Begin Cleanup..."）。
    - 清理后（退出阶段）：验证 `activeContext.md`；更新 `.clinerules`（last_action: "Completed Cleanup/Consolidation Phase (All Steps)..."，next_action: "Phase Complete..."）。
