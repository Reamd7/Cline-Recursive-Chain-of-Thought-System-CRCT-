# runtime_inspector.py
"""
运行时检查器 - Runtime Inspector

功能概述：
----------
该模块通过Python的inspect模块在运行时动态检查Python代码，提取比AST分析
更丰富和准确的符号信息。运行时检查能够获取实际的类型信息、继承关系、
函数签名等静态分析难以获取的元数据。

核心功能：
----------
1. 类型注解提取：获取参数和返回值的实际类型信息
2. 继承关系分析：追踪完整的类继承链和方法解析顺序(MRO)
3. 源代码上下文：提取函数/类的源代码和位置信息
4. 装饰器识别：识别应用于类和函数的装饰器
5. 作用域分析：分析闭包依赖和作用域引用
6. 模块导出：识别__all__定义的公开接口

技术特点：
----------
- 动态导入：使用importlib安全地导入和检查模块
- 路径过滤：仅收集code_roots范围内的符号（避免标准库污染）
- 源码清理：去除行尾符，提升embedding质量
- 错误容忍：单个模块失败不影响整体分析

输出格式：
----------
生成runtime_symbols.json，包含每个文件的：
- classes: 类列表，每个包含名称、文档、继承、装饰器、方法等
- functions: 函数列表，每个包含签名、类型注解、闭包依赖等
- exports: __all__导出的符号列表

与AST分析的互补：
-----------------
- 运行时检查：准确的类型、继承、签名（需要代码可运行）
- AST分析：导入语句、调用图、行号（不执行代码）
- 合并策略：由symbol_map_merger.py统一两者优势

作者：Cline Dependency System
版本：v8.0.0
"""

# ============================================================================
# 标准库导入
# ============================================================================
import inspect           # Python对象内省
import sys               # 系统相关功能
import os                # 文件系统操作
import json              # JSON序列化
import importlib.util    # 动态模块导入
import logging           # 日志记录
import typing            # 类型相关工具
import ast               # 抽象语法树（用于源码解析）
import textwrap          # 文本格式化工具
from typing import Dict, Any, List, Set, Optional  # 类型标注

# ============================================================================
# 日志配置
# ============================================================================
# 配置基础日志格式：时间戳 - 日志级别 - 消息
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
# 创建模块级日志记录器
logger = logging.getLogger(__name__)


# ============================================================================
# 类型注解提取函数
# ============================================================================
def get_type_annotations(obj) -> Dict[str, Any]:
    """
    提取函数或方法的参数和返回值类型注解

    详细说明：
    ----------
    该函数使用typing.get_type_hints()获取运行时解析的类型注解，
    比直接读取__annotations__更可靠，因为它会处理前向引用等复杂情况。

    提取内容：
    ----------
    1. parameters: 参数类型字典，键为参数名，值为类型字符串
    2. return_type: 返回值类型的字符串表示

    参数：
    ------
    obj : callable
        要检查的函数或方法对象

    返回：
    ------
    Dict[str, Any]
        包含'parameters'和'return_type'的字典
        如果提取失败（如无类型注解），返回空字典

    异常处理：
    ----------
    捕获所有异常并返回空字典（许多内置函数无类型注解）

    示例：
    ------
    >>> def example(x: int, y: str) -> bool:
    ...     return True
    >>> get_type_annotations(example)
    {'parameters': {'x': 'int', 'y': 'str', 'return': 'bool'},
     'return_type': 'bool'}
    """
    try:
        # ------------------------------------------------------------------------
        # 步骤1: 使用typing.get_type_hints()获取类型注解
        # ------------------------------------------------------------------------
        # include_extras=True: 包含Annotated等扩展类型信息
        return {
            # 参数类型字典：将类型对象转换为字符串
            'parameters': {k: str(v) for k, v in typing.get_type_hints(obj, include_extras=True).items()},
            # 返回值类型：从签名中提取
            'return_type': str(inspect.signature(obj).return_annotation)
        }
    except Exception:
        # ------------------------------------------------------------------------
        # 步骤2: 提取失败时返回空字典
        # ------------------------------------------------------------------------
        # 常见原因：内置函数、C扩展、无类型注解
        return {}


# ============================================================================
# 源代码上下文提取函数
# ============================================================================
def get_source_context(obj, code_roots: List[str]) -> Dict[str, Any]:
    """
    获取对象的源文件位置和导入上下文

    详细说明：
    ----------
    该函数提取对象的源代码位置信息，但仅限于code_roots指定的范围内。
    这样可以避免收集标准库或第三方库的源代码。

    路径验证逻辑：
    ----------
    1. 获取源文件路径
    2. 归一化路径格式
    3. 检查是否在任何code_root下
    4. 如果在范围外，返回空字典（跳过）

    提取内容：
    ----------
    - file: 归一化的源文件路径
    - line_range: (起始行, 结束行)元组
    - source_lines: 源代码行列表（已清理行尾符）

    参数：
    ------
    obj : object
        要检查的Python对象（类、函数、方法等）
    code_roots : List[str]
        允许的代码根目录列表（归一化路径）

    返回：
    ------
    Dict[str, Any]
        包含源文件信息的字典，如果源码不在code_roots内返回空字典

    源码清理：
    ----------
    去除\\n和\\r行尾符，防止JSON中的转义字符污染embedding质量

    示例：
    ------
    >>> context = get_source_context(MyClass, ["/project/src"])
    >>> print(context['file'])
    h:/project/src/mymodule.py
    >>> print(context['line_range'])
    (10, 25)
    """
    try:
        # ------------------------------------------------------------------------
        # 步骤1: 获取源文件路径
        # ------------------------------------------------------------------------
        source_file = inspect.getsourcefile(obj)
        if not source_file:
            # 无法获取源文件（可能是内置对象或C扩展）
            return {}

        # ------------------------------------------------------------------------
        # 步骤2: 归一化并验证路径
        # ------------------------------------------------------------------------
        # 导入路径工具函数
        from cline_utils.dependency_system.utils.path_utils import normalize_path, is_subpath

        # 将源文件路径归一化为h:/格式
        norm_source = normalize_path(source_file)

        # ====================================================================
        # 步骤2.1: 检查文件是否在任何code_root下
        # ====================================================================
        in_code_roots = False
        for code_root in code_roots:
            # 归一化code_root路径
            norm_root = normalize_path(code_root)

            # 检查源文件是否等于或是code_root的子路径
            if norm_source == norm_root or is_subpath(norm_source, norm_root):
                in_code_roots = True
                break

        # ====================================================================
        # 步骤2.2: 如果不在code_roots范围内，跳过
        # ====================================================================
        if not in_code_roots:
            # 记录调试信息
            logger.debug(f"Skipping source outside code roots: {norm_source}")
            return {}

        # ------------------------------------------------------------------------
        # 步骤3: 提取源代码行和起始行号
        # ------------------------------------------------------------------------
        # getsourcelines返回(源代码行列表, 起始行号)
        source_lines, start_line = inspect.getsourcelines(obj)

        # ====================================================================
        # 步骤3.1: 清理源代码行（去除行尾符）
        # ====================================================================
        # 去除\\n和\\r，防止JSON转义污染embedding
        clean_source_lines = [line.rstrip('\n').rstrip('\r') for line in source_lines]

        # ------------------------------------------------------------------------
        # 步骤4: 返回源代码上下文信息
        # ------------------------------------------------------------------------
        return {
            'file': norm_source,                                    # 归一化文件路径
            'line_range': (start_line, start_line + len(source_lines)),  # 行号范围
            'source_lines': clean_source_lines                      # 清理后的源代码
        }

    except Exception:
        # ------------------------------------------------------------------------
        # 步骤5: 提取失败时返回空字典
        # ------------------------------------------------------------------------
        # 常见原因：动态生成的代码、交互式环境等
        return {}


# ============================================================================
# 模块导出识别函数
# ============================================================================
def get_module_exports(module) -> Dict[str, str]:
    """
    识别模块中通过__all__定义的公开接口

    详细说明：
    ----------
    Python模块可以通过__all__列表显式声明公开的接口。该函数提取这些
    导出符号及其来源模块，用于理解模块的公开API。

    __all__的作用：
    ----------
    - from module import * 时只导入__all__中的名称
    - 文档生成工具识别公开接口
    - 区分公开API和内部实现

    参数：
    ------
    module : module
        要检查的Python模块对象

    返回：
    ------
    Dict[str, str]
        导出符号字典，键为符号名，值为定义该符号的模块名
        如果模块没有__all__，返回空字典

    示例：
    ------
    >>> import mymodule
    >>> exports = get_module_exports(mymodule)
    >>> print(exports)
    {'MyClass': 'mymodule', 'my_function': 'mymodule.utils'}
    """
    # ------------------------------------------------------------------------
    # 初始化导出字典
    # ------------------------------------------------------------------------
    exports = {}

    # ------------------------------------------------------------------------
    # 检查模块是否定义了__all__
    # ------------------------------------------------------------------------
    if hasattr(module, '__all__'):
        # ====================================================================
        # 遍历__all__中的每个符号名
        # ====================================================================
        for name in module.__all__:
            # 获取符号对象
            obj = getattr(module, name, None)

            if obj:
                try:
                    # ============================================================
                    # 获取符号的定义模块
                    # ============================================================
                    exports[name] = inspect.getmodule(obj).__name__
                except AttributeError:
                    # ============================================================
                    # 无法获取模块信息，跳过
                    # ============================================================
                    pass

    # ------------------------------------------------------------------------
    # 返回导出符号字典
    # ------------------------------------------------------------------------
    return exports


# ============================================================================
# 继承关系分析函数
# ============================================================================
def get_inheritance_info(cls, code_roots: List[str]) -> Dict[str, Any]:
    """
    提取类的继承层次结构和方法解析顺序(MRO)

    详细说明：
    ----------
    该函数分析类的继承关系，但仅包含code_roots范围内的基类。
    这样可以聚焦于项目内部的继承关系，忽略标准库基类。

    提取内容：
    ----------
    1. bases: 直接基类列表（仅code_roots内）
    2. mro: 方法解析顺序列表（仅code_roots内，不包括自身）

    MRO (Method Resolution Order)：
    ----------
    Python使用C3线性化算法确定多重继承时的方法查找顺序。
    MRO列表显示了方法查找的完整路径。

    路径过滤：
    ----------
    对每个基类检查其源文件是否在code_roots内，只保留项目内的类

    参数：
    ------
    cls : type
        要检查的类对象
    code_roots : List[str]
        允许的代码根目录列表

    返回：
    ------
    Dict[str, Any]
        包含'bases'和'mro'列表的字典
        如果提取失败返回空字典

    格式：
    ------
    类名使用完全限定名：module_name.ClassName

    示例：
    ------
    >>> class Base: pass
    >>> class Derived(Base): pass
    >>> get_inheritance_info(Derived, ["/project"])
    {'bases': ['mymodule.Base'], 'mro': ['mymodule.Base', 'builtins.object']}
    """
    # ------------------------------------------------------------------------
    # 导入路径工具
    # ------------------------------------------------------------------------
    from cline_utils.dependency_system.utils.path_utils import normalize_path, is_subpath

    try:
        # ====================================================================
        # 步骤1: 提取直接基类（仅code_roots内）
        # ====================================================================
        bases = []
        for base in cls.__bases__:
            try:
                # ------------------------------------------------------------
                # 步骤1.1: 获取基类的源文件
                # ------------------------------------------------------------
                base_file = inspect.getsourcefile(base)

                if base_file:
                    # --------------------------------------------------------
                    # 步骤1.2: 归一化路径
                    # --------------------------------------------------------
                    norm_base_file = normalize_path(base_file)

                    # --------------------------------------------------------
                    # 步骤1.3: 检查是否在code_roots内
                    # --------------------------------------------------------
                    in_roots = any(
                        norm_base_file == normalize_path(root) or
                        is_subpath(norm_base_file, normalize_path(root))
                        for root in code_roots
                    )

                    # --------------------------------------------------------
                    # 步骤1.4: 如果在范围内，添加到列表
                    # --------------------------------------------------------
                    if in_roots:
                        # 使用完全限定名：module.ClassName
                        bases.append(base.__module__ + '.' + base.__qualname__)

            except (TypeError, AttributeError):
                # ------------------------------------------------------------
                # 无法获取基类信息，跳过
                # ------------------------------------------------------------
                pass

        # ====================================================================
        # 步骤2: 提取方法解析顺序（仅code_roots内）
        # ====================================================================
        mro = []
        # inspect.getmro(cls)[1:] 跳过自身，从第一个父类开始
        for c in inspect.getmro(cls)[1:]:  # Skip self
            try:
                # ------------------------------------------------------------
                # 步骤2.1: 获取MRO类的源文件
                # ------------------------------------------------------------
                c_file = inspect.getsourcefile(c)

                if c_file:
                    # --------------------------------------------------------
                    # 步骤2.2: 归一化路径
                    # --------------------------------------------------------
                    norm_c_file = normalize_path(c_file)

                    # --------------------------------------------------------
                    # 步骤2.3: 检查是否在code_roots内
                    # --------------------------------------------------------
                    in_roots = any(
                        norm_c_file == normalize_path(root) or
                        is_subpath(norm_c_file, normalize_path(root))
                        for root in code_roots
                    )

                    # --------------------------------------------------------
                    # 步骤2.4: 如果在范围内，添加到MRO列表
                    # --------------------------------------------------------
                    if in_roots:
                        mro.append(c.__module__ + '.' + c.__qualname__)

            except (TypeError, AttributeError):
                # ------------------------------------------------------------
                # 无法获取MRO类信息，跳过
                # ------------------------------------------------------------
                pass

        # ====================================================================
        # 步骤3: 返回继承信息
        # ====================================================================
        return {
            'bases': bases,  # 直接基类列表
            'mro': mro       # 方法解析顺序
        }

    except Exception:
        # ====================================================================
        # 步骤4: 提取失败返回空字典
        # ====================================================================
        return {}


# ============================================================================
# 闭包依赖分析函数
# ============================================================================
def get_closure_dependencies(func, code_roots: List[str]) -> List[str]:
    """
    识别函数闭包中捕获的变量依赖

    详细说明：
    ----------
    闭包是指函数引用了外部作用域的变量。该函数分析闭包捕获的对象，
    提取其所属模块，但仅包含code_roots范围内的模块。

    闭包示例：
    ----------
    >>> def outer():
    ...     x = 10
    ...     def inner():
    ...         return x  # inner捕获了外部变量x
    ...     return inner

    应用场景：
    ----------
    - 识别函数的隐式依赖
    - 理解函数的上下文需求
    - 分析模块间的数据流

    参数：
    ------
    func : function
        要检查的函数对象
    code_roots : List[str]
        允许的代码根目录列表

    返回：
    ------
    List[str]
        闭包依赖的模块名列表（已去重）
        如果无闭包或不在code_roots内，返回空列表

    示例：
    ------
    >>> import mymodule
    >>> def make_handler():
    ...     config = mymodule.Config()
    ...     def handler():
    ...         return config.value
    ...     return handler
    >>> get_closure_dependencies(make_handler(), ["/project"])
    ['mymodule']
    """
    # ------------------------------------------------------------------------
    # 导入路径工具
    # ------------------------------------------------------------------------
    from cline_utils.dependency_system.utils.path_utils import normalize_path, is_subpath

    # ------------------------------------------------------------------------
    # 初始化依赖列表
    # ------------------------------------------------------------------------
    deps = []

    # ------------------------------------------------------------------------
    # 检查是否为函数且有闭包
    # ------------------------------------------------------------------------
    if inspect.isfunction(func) and func.__closure__:
        # ====================================================================
        # 遍历闭包中的每个cell（捕获的变量）
        # ====================================================================
        for cell in func.__closure__:
            try:
                # ------------------------------------------------------------
                # 步骤1: 获取cell中的对象
                # ------------------------------------------------------------
                obj = cell.cell_contents

                # ------------------------------------------------------------
                # 步骤2: 获取对象所属的模块
                # ------------------------------------------------------------
                module = inspect.getmodule(obj)

                if module:
                    try:
                        # --------------------------------------------------------
                        # 步骤3: 获取模块的源文件
                        # --------------------------------------------------------
                        module_file = inspect.getsourcefile(module)

                        if module_file:
                            # ----------------------------------------------------
                            # 步骤4: 归一化路径
                            # ----------------------------------------------------
                            norm_module_file = normalize_path(module_file)

                            # ----------------------------------------------------
                            # 步骤5: 检查是否在code_roots内
                            # ----------------------------------------------------
                            in_roots = any(
                                norm_module_file == normalize_path(root) or
                                is_subpath(norm_module_file, normalize_path(root))
                                for root in code_roots
                            )

                            # ----------------------------------------------------
                            # 步骤6: 如果在范围内，添加模块名
                            # ----------------------------------------------------
                            if in_roots:
                                deps.append(module.__name__)

                    except (TypeError, AttributeError):
                        # --------------------------------------------------------
                        # 无法获取模块源文件，跳过
                        # --------------------------------------------------------
                        pass

            except Exception:
                # ------------------------------------------------------------
                # 无法获取cell内容，跳过
                # ------------------------------------------------------------
                pass

    # ------------------------------------------------------------------------
    # 返回去重后的依赖列表
    # ------------------------------------------------------------------------
    return list(set(deps))


# ============================================================================
# 装饰器识别函数
# ============================================================================
def get_decorator_info(obj, code_roots: List[str]) -> List[str]:
    """
    从包装对象中提取装饰器信息

    详细说明：
    ----------
    装饰器通过__wrapped__属性形成包装链。该函数沿着包装链提取
    装饰器模块，但仅包含code_roots范围内的装饰器。

    装饰器链：
    ----------
    @decorator1
    @decorator2
    def func():
        pass

    结果：func.__wrapped__ -> 被decorator2包装的版本
         func.__wrapped__.__wrapped__ -> 原始函数

    参数：
    ------
    obj : object
        被装饰的对象（函数、方法、类等）
    code_roots : List[str]
        允许的代码根目录列表

    返回：
    ------
    List[str]
        装饰器所属模块名列表
        如果无装饰器或不在code_roots内，返回空列表

    示例：
    ------
    >>> from functools import lru_cache
    >>> from myproject.decorators import timing
    >>> @timing
    ... @lru_cache
    ... def my_func():
    ...     pass
    >>> get_decorator_info(my_func, ["/project"])
    ['myproject.decorators']  # lru_cache被过滤（标准库）
    """
    # ------------------------------------------------------------------------
    # 导入路径工具
    # ------------------------------------------------------------------------
    from cline_utils.dependency_system.utils.path_utils import normalize_path, is_subpath

    # ------------------------------------------------------------------------
    # 初始化装饰器列表
    # ------------------------------------------------------------------------
    decorators = []

    # ------------------------------------------------------------------------
    # 沿着包装链追踪装饰器
    # ------------------------------------------------------------------------
    while hasattr(obj, '__wrapped__'):
        try:
            # ================================================================
            # 步骤1: 获取当前包装层的模块
            # ================================================================
            wrapper_module = inspect.getmodule(obj)

            if wrapper_module:
                try:
                    # --------------------------------------------------------
                    # 步骤2: 获取模块源文件
                    # --------------------------------------------------------
                    wrapper_file = inspect.getsourcefile(wrapper_module)

                    if wrapper_file:
                        # ----------------------------------------------------
                        # 步骤3: 归一化路径
                        # ----------------------------------------------------
                        norm_wrapper_file = normalize_path(wrapper_file)

                        # ----------------------------------------------------
                        # 步骤4: 检查是否在code_roots内
                        # ----------------------------------------------------
                        in_roots = any(
                            norm_wrapper_file == normalize_path(root) or
                            is_subpath(norm_wrapper_file, normalize_path(root))
                            for root in code_roots
                        )

                        # ----------------------------------------------------
                        # 步骤5: 如果在范围内，添加模块名
                        # ----------------------------------------------------
                        if in_roots:
                            decorators.append(wrapper_module.__name__)

                except (TypeError, AttributeError):
                    # --------------------------------------------------------
                    # 无法获取模块源文件，跳过
                    # --------------------------------------------------------
                    pass

            # ================================================================
            # 步骤6: 移动到下一层包装
            # ================================================================
            obj = obj.__wrapped__

        except Exception:
            # ================================================================
            # 步骤7: 遇到错误时终止追踪
            # ================================================================
            break

    # ------------------------------------------------------------------------
    # 返回装饰器模块列表
    # ------------------------------------------------------------------------
    return decorators


# ============================================================================
# 作用域引用分析函数
# ============================================================================
def get_scope_references(func) -> Dict[str, List[str]]:
    """
    提取函数的全局变量和非局部变量引用

    详细说明：
    ----------
    Python字节码中记录了函数引用的外部变量。该函数通过__code__对象
    提取这些作用域引用，帮助理解函数的外部依赖。

    引用类型：
    ----------
    1. globals (co_names): 函数中引用的全局名称
    2. nonlocals (co_freevars): 闭包中的自由变量

    参数：
    ------
    func : function
        要检查的函数对象

    返回：
    ------
    Dict[str, List[str]]
        包含'globals'和'nonlocals'列表的字典
        如果提取失败返回空字典

    示例：
    ------
    >>> global_var = 10
    >>> def outer():
    ...     x = 5
    ...     def inner():
    ...         return x + global_var  # x是nonlocal，global_var是global
    ...     return inner
    >>> get_scope_references(outer())
    {'globals': ['global_var'], 'nonlocals': ['x']}
    """
    try:
        # ------------------------------------------------------------------------
        # 步骤1: 获取函数的字节码对象
        # ------------------------------------------------------------------------
        code = func.__code__

        # ------------------------------------------------------------------------
        # 步骤2: 提取作用域引用
        # ------------------------------------------------------------------------
        return {
            # 全局名称：函数中引用的所有非局部名称
            'globals': list(code.co_names),
            # 非局部变量：闭包中捕获的外部变量
            'nonlocals': list(code.co_freevars)
        }

    except Exception:
        # ------------------------------------------------------------------------
        # 步骤3: 提取失败返回空字典
        # ------------------------------------------------------------------------
        # 常见原因：内置函数、C扩展等
        return {}


# ============================================================================
# 属性访问分析函数
# ============================================================================
def get_attribute_accesses(source_code: str) -> Set[str]:
    """
    解析源代码以识别属性访问模式

    详细说明：
    ----------
    该函数使用AST解析源代码，提取所有属性访问（obj.attr形式）。
    这有助于理解代码中使用了哪些对象的属性。

    AST遍历：
    ----------
    遍历抽象语法树，查找ast.Attribute节点，提取attr属性名

    参数：
    ------
    source_code : str
        函数或方法的源代码字符串

    返回：
    ------
    Set[str]
        访问的属性名集合
        如果解析失败返回空列表

    示例：
    ------
    >>> code = '''
    ... def example(obj):
    ...     return obj.name + obj.value
    ... '''
    >>> get_attribute_accesses(code)
    ['name', 'value']
    """
    # ------------------------------------------------------------------------
    # 初始化属性访问集合
    # ------------------------------------------------------------------------
    accesses = set()

    try:
        # ====================================================================
        # 步骤1: 去除缩进（AST解析要求顶级缩进）
        # ====================================================================
        dedented_source = textwrap.dedent(source_code)

        # ====================================================================
        # 步骤2: 解析源代码为AST
        # ====================================================================
        tree = ast.parse(dedented_source)

        # ====================================================================
        # 步骤3: 遍历AST查找属性访问节点
        # ====================================================================
        for node in ast.walk(tree):
            # 检查是否为属性访问节点（obj.attr）
            if isinstance(node, ast.Attribute):
                # 添加属性名到集合
                accesses.add(node.attr)

    except Exception:
        # ====================================================================
        # 步骤4: 解析失败时跳过
        # ====================================================================
        # 常见原因：语法错误、不完整的代码片段等
        pass

    # ------------------------------------------------------------------------
    # 返回属性访问列表
    # ------------------------------------------------------------------------
    return list(accesses)


# ============================================================================
# 模块检查主函数
# ============================================================================
def get_module_info(file_path: str, module_name: str, code_roots: List[str]) -> Dict[str, Any]:
    """
    安全导入模块并使用inspect提取符号信息

    详细说明：
    ----------
    该函数是运行时检查的核心，负责：
    1. 动态导入模块
    2. 检查模块中的所有成员
    3. 提取类和函数的详细信息
    4. 验证所有路径都在code_roots范围内

    工作流程：
    ----------
    1. 将模块所在目录添加到sys.path（处理相对导入）
    2. 使用importlib动态导入模块
    3. 遍历模块成员，分类为类和函数
    4. 对每个符号提取详细元数据
    5. 清理sys.path

    路径验证：
    ----------
    所有提取的源代码上下文都会验证是否在code_roots内，
    确保不收集标准库或第三方库的信息

    参数：
    ------
    file_path : str
        模块文件的绝对路径
    module_name : str
        模块的完全限定名（如cline_utils.example）
    code_roots : List[str]
        允许的代码根目录列表

    返回：
    ------
    Dict[str, Any]
        包含以下键的字典：
        - classes: 类信息列表
        - functions: 函数信息列表
        - exports: 导出符号字典
        如果导入失败返回空字典

    异常处理：
    ----------
    任何导入或检查错误都会被捕获并记录警告，不会中断整体分析

    示例：
    ------
    >>> info = get_module_info(
    ...     "/project/mymodule.py",
    ...     "mymodule",
    ...     ["/project"]
    ... )
    >>> print(info['classes'][0]['name'])
    MyClass
    """
    try:
        # ------------------------------------------------------------------------
        # 步骤1: 准备导入环境
        # ------------------------------------------------------------------------
        # ====================================================================
        # 步骤1.1: 获取模块所在目录
        # ====================================================================
        file_dir = os.path.dirname(file_path)

        # ====================================================================
        # 步骤1.2: 添加到sys.path以支持相对导入
        # ====================================================================
        if file_dir not in sys.path:
            sys.path.insert(0, file_dir)

        # ------------------------------------------------------------------------
        # 步骤2: 动态导入模块
        # ------------------------------------------------------------------------
        # ====================================================================
        # 步骤2.1: 创建模块spec
        # ====================================================================
        spec = importlib.util.spec_from_file_location(module_name, file_path)
        if not spec or not spec.loader:
            return {}

        # ====================================================================
        # 步骤2.2: 创建模块对象
        # ====================================================================
        module = importlib.util.module_from_spec(spec)

        # ====================================================================
        # 步骤2.3: 注册到sys.modules
        # ====================================================================
        sys.modules[module_name] = module

        # ====================================================================
        # 步骤2.4: 执行模块代码
        # ====================================================================
        spec.loader.exec_module(module)

        # ------------------------------------------------------------------------
        # 步骤3: 初始化符号收集结构
        # ------------------------------------------------------------------------
        symbols = {
            "classes": [],                           # 类列表
            "functions": [],                         # 函数列表
            "exports": get_module_exports(module)    # 导出符号
        }

        # ------------------------------------------------------------------------
        # 步骤4: 遍历模块成员
        # ------------------------------------------------------------------------
        for name, obj in inspect.getmembers(module):
            # ================================================================
            # 步骤4.1: 处理类
            # ================================================================
            if inspect.isclass(obj) and obj.__module__ == module_name:
                # ------------------------------------------------------------
                # 步骤4.1.1: 获取类的源代码上下文
                # ------------------------------------------------------------
                source_context = get_source_context(obj, code_roots)

                # ------------------------------------------------------------
                # 步骤4.1.2: 验证源代码在code_roots范围内
                # ------------------------------------------------------------
                if not source_context:
                    logger.debug(f"Skipping class {name} - source outside code roots")
                    continue

                # ------------------------------------------------------------
                # 步骤4.1.3: 构建类信息字典
                # ------------------------------------------------------------
                class_info = {
                    "name": name,                                      # 类名
                    "docstring": inspect.getdoc(obj),                  # 文档字符串
                    "inheritance": get_inheritance_info(obj, code_roots),  # 继承关系
                    "decorators": get_decorator_info(obj, code_roots),     # 装饰器
                    "source_context": source_context,                  # 源代码上下文
                    "methods": []                                      # 方法列表（待填充）
                }

                # ------------------------------------------------------------
                # 步骤4.1.4: 遍历类的方法
                # ------------------------------------------------------------
                for method_name, method in inspect.getmembers(obj):
                    # 检查是否为函数或方法
                    if inspect.isfunction(method) or inspect.ismethod(method):
                        # --------------------------------------------------------
                        # 步骤4.1.4.1: 验证方法源代码
                        # --------------------------------------------------------
                        method_source_context = get_source_context(method, code_roots)
                        if not method_source_context:
                            logger.debug(f"Skipping method {method_name} - source outside code roots")
                            continue

                        # --------------------------------------------------------
                        # 步骤4.1.4.2: 获取方法签名
                        # --------------------------------------------------------
                        try:
                            sig = str(inspect.signature(method))
                        except ValueError:
                            # 无法获取签名（如内置方法）
                            sig = "(...)"

                        # --------------------------------------------------------
                        # 步骤4.1.4.3: 获取方法源代码用于属性访问分析
                        # --------------------------------------------------------
                        try:
                            source = inspect.getsource(method)
                            attr_accesses = get_attribute_accesses(source)
                        except Exception:
                            attr_accesses = []

                        # --------------------------------------------------------
                        # 步骤4.1.4.4: 添加方法信息到类
                        # --------------------------------------------------------
                        class_info["methods"].append({
                            "name": method_name,                                # 方法名
                            "signature": sig,                                   # 方法签名
                            "docstring": inspect.getdoc(method),                # 文档字符串
                            "type_annotations": get_type_annotations(method),   # 类型注解
                            "closure_dependencies": get_closure_dependencies(method, code_roots),  # 闭包依赖
                            "scope_references": get_scope_references(method),   # 作用域引用
                            "decorators": get_decorator_info(method, code_roots),  # 装饰器
                            "source_context": method_source_context,            # 源代码上下文
                            "attribute_accesses": attr_accesses                 # 属性访问
                        })

                # ------------------------------------------------------------
                # 步骤4.1.5: 添加类信息到符号列表
                # ------------------------------------------------------------
                symbols["classes"].append(class_info)

            # ================================================================
            # 步骤4.2: 处理模块级函数
            # ================================================================
            elif inspect.isfunction(obj) and obj.__module__ == module_name:
                # ------------------------------------------------------------
                # 步骤4.2.1: 获取函数源代码上下文
                # ------------------------------------------------------------
                source_context = get_source_context(obj, code_roots)

                # ------------------------------------------------------------
                # 步骤4.2.2: 验证源代码在code_roots范围内
                # ------------------------------------------------------------
                if not source_context:
                    logger.debug(f"Skipping function {name} - source outside code roots")
                    continue

                # ------------------------------------------------------------
                # 步骤4.2.3: 获取函数签名
                # ------------------------------------------------------------
                try:
                    sig = str(inspect.signature(obj))
                except ValueError:
                    sig = "(...)"

                # ------------------------------------------------------------
                # 步骤4.2.4: 获取函数源代码用于属性访问分析
                # ------------------------------------------------------------
                try:
                    source = inspect.getsource(obj)
                    attr_accesses = get_attribute_accesses(source)
                except Exception:
                    attr_accesses = []

                # ------------------------------------------------------------
                # 步骤4.2.5: 添加函数信息到符号列表
                # ------------------------------------------------------------
                symbols["functions"].append({
                    "name": name,                                        # 函数名
                    "signature": sig,                                    # 函数签名
                    "docstring": inspect.getdoc(obj),                    # 文档字符串
                    "type_annotations": get_type_annotations(obj),       # 类型注解
                    "closure_dependencies": get_closure_dependencies(obj, code_roots),  # 闭包依赖
                    "scope_references": get_scope_references(obj),       # 作用域引用
                    "decorators": get_decorator_info(obj, code_roots),   # 装饰器
                    "source_context": source_context,                    # 源代码上下文
                    "attribute_accesses": attr_accesses                  # 属性访问
                })

        # ------------------------------------------------------------------------
        # 步骤5: 返回收集的符号信息
        # ------------------------------------------------------------------------
        return symbols

    except Exception as e:
        # ------------------------------------------------------------------------
        # 步骤6: 处理导入或检查错误
        # ------------------------------------------------------------------------
        logger.warning(f"Failed to inspect {file_path}: {e}")
        return {}

    finally:
        # ------------------------------------------------------------------------
        # 步骤7: 清理sys.path
        # ------------------------------------------------------------------------
        if file_dir in sys.path:
            sys.path.remove(file_dir)


# ============================================================================
# 主程序入口
# ============================================================================
def main():
    """
    运行时检查器的主入口函数

    工作流程：
    ----------
    1. 解析命令行参数（项目根目录）
    2. 初始化ConfigManager
    3. 加载配置（code_roots、排除项等）
    4. 遍历code_roots中的所有Python文件
    5. 对每个文件调用get_module_info()
    6. 将所有符号信息保存到runtime_symbols.json

    命令行用法：
    ----------
    python runtime_inspector.py <project_root>

    输出文件：
    ----------
    <project_root>/cline_utils/dependency_system/core/runtime_symbols.json

    配置项：
    ----------
    - code_roots: 要检查的代码根目录列表
    - excluded_dirs: 排除的目录名
    - excluded_extensions: 排除的文件扩展名
    - excluded_paths: 排除的完整路径

    异常处理：
    ----------
    - 单个文件检查失败不影响其他文件
    - 配置加载失败会终止程序
    - 最终保存JSON时使用ensure_ascii=False防止转义污染
    """
    # ------------------------------------------------------------------------
    # 步骤1: 检查命令行参数
    # ------------------------------------------------------------------------
    if len(sys.argv) < 2:
        print("Usage: python runtime_inspector.py <project_root>")
        sys.exit(1)

    # ------------------------------------------------------------------------
    # 步骤2: 获取项目根目录
    # ------------------------------------------------------------------------
    project_root = os.path.abspath(sys.argv[1])

    # ------------------------------------------------------------------------
    # 步骤3: 添加项目根目录到sys.path
    # ------------------------------------------------------------------------
    # 允许导入cline_utils模块
    if project_root not in sys.path:
        sys.path.insert(0, project_root)

    # ------------------------------------------------------------------------
    # 步骤4: 导入配置管理器
    # ------------------------------------------------------------------------
    try:
        from cline_utils.dependency_system.utils.config_manager import ConfigManager
        from cline_utils.dependency_system.utils.path_utils import normalize_path
    except ImportError as e:
        logger.error(f"Could not import ConfigManager: {e}. Ensure cline_utils is in python path.")
        sys.exit(1)

    # ------------------------------------------------------------------------
    # 步骤5: 初始化配置管理器
    # ------------------------------------------------------------------------
    # ========================================================================
    # 步骤5.1: 切换到项目根目录
    # ========================================================================
    original_cwd = os.getcwd()
    os.chdir(project_root)

    try:
        # ====================================================================
        # 步骤5.2: 创建ConfigManager实例
        # ====================================================================
        config_manager = ConfigManager()

        # ====================================================================
        # 步骤5.3: 加载配置
        # ====================================================================
        # 获取代码根目录列表（已归一化）
        code_roots = config_manager.get_code_root_directories()
        # 获取排除的目录名集合
        excluded_dirs = set(config_manager.get_excluded_dirs())
        # 获取排除的文件扩展名集合
        excluded_extensions = set(config_manager.get_excluded_extensions())
        # 获取排除的完整路径集合
        excluded_paths = set(config_manager.get_excluded_paths())

        logger.info(f"Loaded configuration. Code roots: {code_roots}")

        # ====================================================================
        # 步骤5.4: 转换code_roots为绝对路径
        # ====================================================================
        absolute_code_roots = []
        for root_dir_rel in code_roots:
            if os.path.isabs(root_dir_rel):
                # 已经是绝对路径
                absolute_code_roots.append(normalize_path(root_dir_rel))
            else:
                # 相对路径，拼接项目根目录
                absolute_code_roots.append(normalize_path(os.path.join(project_root, root_dir_rel)))

        logger.info(f"Absolute code roots for validation: {absolute_code_roots}")

        # ====================================================================
        # 步骤5.5: 准备输出目录
        # ====================================================================
        # 输出到 cline_utils/dependency_system/core/runtime_symbols.json
        core_dir = os.path.join(project_root, "cline_utils", "dependency_system", "core")
        os.makedirs(core_dir, exist_ok=True)
        output_file = os.path.join(core_dir, "runtime_symbols.json")

        # ====================================================================
        # 步骤5.6: 初始化符号收集字典
        # ====================================================================
        all_symbols = {}

        # ====================================================================
        # 步骤5.7: 检查是否有code_roots配置
        # ====================================================================
        if not code_roots:
            logger.warning("No code roots defined in configuration. Skipping runtime inspection.")
            sys.exit(0)

        # ------------------------------------------------------------------------
        # 步骤6: 遍历每个code_root
        # ------------------------------------------------------------------------
        for root_dir_rel in code_roots:
            # ================================================================
            # 步骤6.1: 解析为绝对路径
            # ================================================================
            if os.path.isabs(root_dir_rel):
                root_dir = root_dir_rel
            else:
                root_dir = os.path.join(project_root, root_dir_rel)

            # 归一化路径
            root_dir = normalize_path(root_dir)

            # ================================================================
            # 步骤6.2: 检查目录是否存在
            # ================================================================
            if not os.path.exists(root_dir):
                logger.warning(f"Code root not found: {root_dir}")
                continue

            logger.info(f"Scanning root: {root_dir}")

            # ================================================================
            # 步骤6.3: 遍历目录树
            # ================================================================
            for root, dirs, files in os.walk(root_dir):
                # 归一化当前目录路径
                root = normalize_path(root)

                # ------------------------------------------------------------
                # 步骤6.3.1: 过滤排除的目录
                # ------------------------------------------------------------
                # 就地修改dirs列表以跳过排除的目录
                dirs[:] = [d for d in dirs if d not in excluded_dirs]

                # ------------------------------------------------------------
                # 步骤6.3.2: 过滤排除的完整路径
                # ------------------------------------------------------------
                valid_dirs = []
                for d in dirs:
                    dir_path = normalize_path(os.path.join(root, d))
                    if dir_path not in excluded_paths:
                        valid_dirs.append(d)
                dirs[:] = valid_dirs

                # ------------------------------------------------------------
                # 步骤6.3.3: 遍历文件
                # ------------------------------------------------------------
                for file in files:
                    # --------------------------------------------------------
                    # 过滤非Python文件和__开头的文件
                    # --------------------------------------------------------
                    if not file.endswith(".py") or file.startswith("__"):
                        continue

                    # --------------------------------------------------------
                    # 检查文件扩展名是否被排除
                    # --------------------------------------------------------
                    _, ext = os.path.splitext(file)
                    if ext in excluded_extensions:
                        continue

                    # --------------------------------------------------------
                    # 构建完整文件路径
                    # --------------------------------------------------------
                    file_path = normalize_path(os.path.join(root, file))

                    # --------------------------------------------------------
                    # 检查完整路径是否被排除
                    # --------------------------------------------------------
                    if file_path in excluded_paths:
                        continue

                    # --------------------------------------------------------
                    # 构建模块名（近似）
                    # --------------------------------------------------------
                    # 相对于项目根的路径
                    rel_path = os.path.relpath(file_path, project_root)
                    # 转换为模块名格式
                    module_name = rel_path.replace(os.sep, ".").replace(".py", "")

                    logger.info(f"Inspecting {module_name}...")

                    # --------------------------------------------------------
                    # 步骤6.3.4: 检查模块并收集符号
                    # --------------------------------------------------------
                    # 传递absolute_code_roots用于路径验证
                    info = get_module_info(file_path, module_name, absolute_code_roots)

                    if info:
                        # 将符号信息添加到结果字典
                        all_symbols[file_path] = info

        # ------------------------------------------------------------------------
        # 步骤7: 保存符号信息到JSON文件
        # ------------------------------------------------------------------------
        # ====================================================================
        # 使用ensure_ascii=False防止转义字符污染embedding
        # ====================================================================
        with open(output_file, "w", encoding="utf-8") as f:
            json.dump(
                all_symbols,           # 所有符号信息
                f,                     # 文件对象
                indent=2,              # 2空格缩进
                ensure_ascii=False     # 保留非ASCII字符（中文等）
            )

        logger.info(f"Runtime inspection complete. Saved to {output_file}")

    finally:
        # ------------------------------------------------------------------------
        # 步骤8: 恢复原始工作目录
        # ------------------------------------------------------------------------
        os.chdir(original_cwd)


# ============================================================================
# 脚本入口点
# ============================================================================
if __name__ == "__main__":
    main()
